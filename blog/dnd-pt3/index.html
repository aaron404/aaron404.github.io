<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>Making games play themselves with Rust Part 3: Solving Puzzles with Backtracking</title><meta content="Making games play themselves with Rust Part 3: Solving Puzzles with Backtracking" name=title><meta content=Aaron name=author><meta content="Using recursion instead of my brain!" name=description><meta content=website property=og:type><meta content=https://aaron404.github.io/blog/dnd-pt3/ property=og:url><meta content="My Blog" property=og:site_name><meta content="Making games play themselves with Rust Part 3: Solving Puzzles with Backtracking" property=og:title><meta content="Using recursion instead of my brain!" property=og:description><meta content=https://aaron404.github.io/blog/dnd-pt1/og_image.webp property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://aaron404.github.io/blog/dnd-pt3/ property=twitter:url><meta content="Making games play themselves with Rust Part 3: Solving Puzzles with Backtracking" property=twitter:title><meta content="Using recursion instead of my brain!" property=twitter:description><meta content=https://aaron404.github.io/blog/dnd-pt1/og_image.webp property=twitter:image><link href=https://aaron404.github.io/blog/dnd-pt3/ rel=canonical><link rel="shortcut icon" href=https://aaron404.github.io/favicon.ico type=image/x-icon><link href=https://aaron404.github.io/css/style.css rel=stylesheet><script defer src=https://aaron404.github.io/js/script.js></script><body><div class=wrapper><header><nav class=navBar><a href=/> home </a><a href=/journal> journal </a><a href=/blog> blog </a><div class=themeSwitch><button class="themeButton dark" onclick="setTheme('dark')" title="Dark mode"><svg class="icons icons__background"><use href=https://aaron404.github.io/icons.svg#darkMode></use></svg></button><button class="themeButton light" onclick="setTheme('light')" title="Light mode"><svg class="icons icons__background"><use href=https://aaron404.github.io/icons.svg#lightMode></use></svg></button></div></nav></header><main><time datetime=2025-10-22>Published on: <span class=metaData>2025-10-22</span></time><h1>Making games play themselves with Rust Part 3: Solving Puzzles with Backtracking</h1><h2>Table of contents</h2><ul><li><a href=https://aaron404.github.io/blog/dnd-pt3/#introduction>Introduction</a><li><a href=https://aaron404.github.io/blog/dnd-pt3/#primer-on-backtracking>Primer on Backtracking</a><li><a href=https://aaron404.github.io/blog/dnd-pt3/#napkin-math>Napkin Math</a><li><a href=https://aaron404.github.io/blog/dnd-pt3/#first-attempt>First Attempt</a><li><a href=https://aaron404.github.io/blog/dnd-pt3/#correctness-and-performance-improvements>Correctness and Performance Improvements</a><li><a href=https://aaron404.github.io/blog/dnd-pt3/#results>Results</a><li><a href=https://aaron404.github.io/blog/dnd-pt3/#conclusion>Conclusion</a><li><a href=https://aaron404.github.io/blog/dnd-pt3/#additional-thoughts>Additional Thoughts</a></ul><h1 id=introduction>Introduction</h1><p>In the last post I covered the process of parsing the game state from a screenshot. While the end result is fairly simple and requires a small amount of code, it took a pretty large amount of effort to get there. Today it’s time to actually solve puzzles, and I’ll be doing so using an algorithm called backtracking in lieu of proper logical deduction. Today I’ll cover:<ol><li>Some background on backtracking and its feasibility<li>A naive solver implementation<li>Optimizing the solver<li>Solving millions of puzzles<li>A reflection on this whole project</ol><h1 id=primer-on-backtracking>Primer on Backtracking</h1><p>(If you’re familiar with backtracking, feel free to skip this section)<p><a href=https://en.wikipedia.org/wiki/Backtracking rel=noopener target=_blank>Backtracking</a> is a simple algorithm often used to find solutions to constraint problems. Let’s take everyone’s favourite logic puzzle, Sudoku, as an example. Sudoku has 3 constraints.<ol><li>Every row must contain one of each digit 1-9<li>Every column must contain one of each digit 1-9<li>Every 3x3 subregion must contain one of each digit 1-9.</ol><p>A Sudoku puzzle is presented as an incomplete 9x9 grid which can be uniquely filled in by successive application of only the 3 rules above. For example in the puzzle below, I can place a <code>4</code> in the highlighted square because the other <code>4</code>s in the puzzle exclude the use of <code>4</code> in all but one square in that 3x3 subregion.<div class=textCenter><a class=img-link href=sudoku.webp><img alt="Sudoku example" src=sudoku.webp></a><div class=caption>Deduction of the position of a 4.</div><br></div><p>I won’t go into detail here, but there are <a href=https://www.sudokudragon.com/sudokustrategy.htm rel=noopener target=_blank>many</a> <a href=https://www.sudokudragon.com/advancedstrategy.htm rel=noopener target=_blank>techniques</a> which can be employed to deduce unsolved clues in a Sudoku. However, as you try to solve harder and harder puzzles (such as the minimal 17-clue Sudoku), the techniques become complicated enough that sometimes it’s easier to just guess and hope for the best. For example, if you know a square can only be a <code>3</code> or a <code>6</code>, you can just assume it is <code>3</code> and continue with the puzzle until you either solve the puzzle or reach a contradiction. Reaching a contradition means you can ‘undo’ the moves to the point where you made the guess, and instead go with <code>6</code> because you’ve now proven <code>3</code> can’t work.<p>I’ve heard this strategy called “guess and check” or “trial and error”, but in computer science it is called <em>backtracking</em>. The number of empty squares indicates the <em>depth</em> of the solution space, where each attempted solution requires N=<em>depth</em> guesses to fill out the entire puzzle. This is a pretty frustrating and unfun way to solve puzzles by hand, but for computers it is often one of the easiest ways to implement a solver.<p>Turning our attention back to Dungeons and Diagrams, puzzles are instead presented on an 8x8 grid with somewhere between 3 and 13 clues given (values gathered empirically). The player has to deduce the state of the remaining 50-60 empty tiles (which must be either <code>Wall</code> or <code>Path</code>). Before I get into the implementation, here’s a quick refresher on the constraints a solution must obey (I’ve numbered them as they’ll be referred to later):<ol><li>Each row or column must contain a certain number of walls, indicated by the adjacent number<li>All empty space must be part of a hallway or treasure room<li>Treasure rooms are always 3x3 with a single entrance<li>Hallways are always one space wide. Outside of a treasure room there will never be a 2x2 block of empty spaces.<li>Every monster is in a dead end. Every dead end must contain a monster<li>All empty spaces connect into a single contiguous shape. Diagonal spaces are not considered connected</ol><h1 id=napkin-math>Napkin Math</h1><p>Backtracking is <em>simple</em>, but it’s not a silver bullet. Many games such as Chess or Go are famously not solvable (yet?) due to the astronomical number of possible games, which I have seen estimated to be higher than the number of atoms in the universe. Because the puzzle grid is smaller than Sudoku and because I’ve written a backtracking Sudoku solver before (this is a common first year programming assignment), I assumed DnD would also be feasible, but I came up with some heuristics reinforce that assumption.<div class=textCenter><a class=img-link href=upper_bound.webp><img alt="Puzzle to compute upper bound" src=upper_bound.webp></a></div><p>In this puzzle, the rows have varying numbers of walls required and monsters present. Focusing on the bottom row, we can see it has 5 empty tiles, and requires 3 of those to be walls. We can use combinatorics to compute the number of ways to place the walls with the “n choose k” function. For the bottom row, 5 choose 3 (I’ll use 5c3 notation going forward) evaluates to 10.<div class=textCenter><a class=img-link href=combinations.webp><img alt="Wall combinations" src=combinations.webp></a><div class=caption>The 10 unique wall layouts that can be used to complete the bottom row</div><br></div><p>If we repeat this process for all 8 rows, we get 7c1 = 7, 7c6 = 7, 7c6 = 7, 7c2 = 21, 8c7 = 7, 7c3 = 35, 7c3 = 35, and lastly 5c3 = 10. Multiplying all of these numbers together results in a solution space with ~705 million possibilities. This sounds high but is within the realm of possibility for modern computers. Repeating this calculation for a bunch more puzzles, the upper bound hovered around ~4.2 billion. A little scarier but let’s press on!<p>The actual solution space should end up being quite a bit smaller, as we don’t have to evaluate each chain of guesses all the way through the whole puzzle. Like the sudoku puzzle above, we will inevitably run into contradictions if we make a wrong guess early on. When this happens, we don’t have to continue the search from that point and can cut off entire branches of the solution space. The earlier a contradiction is found, the larger the branch we get to prune.<p>As a bit of premature optimization, I also realized that as I made guesses for each row I could keep track of the current wall count in each column, and mask off entire columns as they are filled. This will reduce the number of combinations for subsequent rows being checked.<h1 id=first-attempt>First Attempt</h1><p>My implementation needed to iterate over each empty tile, place a wall if legal, and then recurse to the next tile. This would result in a stack depth of 50-60 depending on the puzzle - an amount which would incur considerable function call overhead throughout the several hundred million calls needed to traverse the solution space. I figured I could instead traverse the puzzle whole rows at a time, considering groups of 8 tiles at a time. This meant the stack would have a maximum depth of 8, and I could replace the lost functionality with a tight <code>for</code> loop that would go through each permutation of wall placements for the entire row.<p>I was also inspired by modern chess engines which use <a href=https://en.wikipedia.org/wiki/Bitboard rel=noopener target=_blank>bitboards</a> to represent the game state in a compact manner that is both fast to copy (useful for recursion) and fast to process (I could use bitwise operators to operate on all 64 tiles in parallel rather than looping over arrays of bytes). I created a new puzzle representation that could be passed into the solver to take advantage of these ideas. With an 8x8 grid and 4 states to track, I chose to use 4 <code>u64</code>s to make bitmaps of each state. I will also keep the <code>top_nums</code> and <code>left_nums</code> fields from before, as they are already pretty compact.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#db784d>pub </span><span style=color:#95cc5e>struct </span><span>Backtracker {
</span><span>    </span><span style=color:#f8bb39>empty_mask</span><span>: </span><span style=color:#95cc5e>u64</span><span>,
</span><span>    </span><span style=color:#f8bb39>wall_mask</span><span>: </span><span style=color:#95cc5e>u64</span><span>,
</span><span>    </span><span style=color:#f8bb39>treasure_mask</span><span>: </span><span style=color:#95cc5e>u64</span><span>,
</span><span>    </span><span style=color:#f8bb39>monster_mask</span><span>: </span><span style=color:#95cc5e>u64</span><span>,
</span><span>    </span><span style=color:#f8bb39>left_nums</span><span>: [</span><span style=color:#95cc5e>u8</span><span>; 8],
</span><span>    </span><span style=color:#f8bb39>top_nums</span><span>: [</span><span style=color:#95cc5e>u8</span><span>; 8],
</span><span>}
</span><span>
</span><span style=color:#95cc5e>impl </span><span>Backtracker {
</span><span>    </span><span style=color:#7a7267>// Convert our existing 'Puzzle' struct to the new bitboard format
</span><span>    </span><span style=color:#db784d>pub </span><span style=color:#95cc5e>fn </span><span style=color:#60a365>new</span><span>(</span><span style=font-style:italic;color:#f8bb39>puzzle</span><span>: </span><span style=color:#db784d>&</span><span>Puzzle) -> </span><span style=color:#95cc5e>Self </span><span>{
</span><span>        </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> empty_mask </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0</span><span style=color:#95cc5e>u64</span><span>;
</span><span>        </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> wall_mask </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0</span><span style=color:#95cc5e>u64</span><span>;
</span><span>        </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> treasure_mask </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0</span><span style=color:#95cc5e>u64</span><span>;
</span><span>        </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> monster_mask </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0</span><span style=color:#95cc5e>u64</span><span>;
</span><span>
</span><span>        </span><span style=color:#7a7267>// Iterate over each tile and set the bits in the corresponding masks
</span><span>        puzzle
</span><span>            .tiles
</span><span>            .</span><span style=color:#95cc5e>as_flattened</span><span>()
</span><span>            .</span><span style=color:#95cc5e>iter</span><span>()
</span><span>            .</span><span style=color:#95cc5e>enumerate</span><span>()
</span><span>            .</span><span style=color:#95cc5e>for_each</span><span>(|(</span><span style=font-style:italic;color:#f8bb39>i</span><span>, </span><span style=font-style:italic;color:#f8bb39>tile</span><span>)| {
</span><span>                </span><span style=color:#95cc5e>let</span><span> bit </span><span style=color:#db784d>= </span><span style=color:#eaae2e>1 </span><span style=color:#db784d><< </span><span>(</span><span style=color:#eaae2e>63 </span><span style=color:#db784d>-</span><span> i);
</span><span>                </span><span style=color:#db784d>match</span><span> tile {
</span><span>                    Tile::Empty </span><span style=color:#db784d>=></span><span> empty_mask </span><span style=color:#db784d>|=</span><span> bit,
</span><span>                    Tile::Wall </span><span style=color:#db784d>=></span><span> wall_mask </span><span style=color:#db784d>|=</span><span> bit,
</span><span>                    Tile::Treasure </span><span style=color:#db784d>=></span><span> treasure_mask </span><span style=color:#db784d>|=</span><span> bit,
</span><span>                    Tile::Monster </span><span style=color:#db784d>=></span><span> monster_mask </span><span style=color:#db784d>|=</span><span> bit,
</span><span>                }
</span><span>            });
</span><span>
</span><span>        </span><span style=color:#95cc5e>Self </span><span>{
</span><span>            empty_mask,
</span><span>            wall_mask,
</span><span>            treasure_mask,
</span><span>            monster_mask,
</span><span>            left_nums: puzzle.left_nums,
</span><span>            top_nums: puzzle.top_nums,
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>Let’s check out an example of parsing a puzzle into this format.<div class=textCenter><a class=img-link href=algorithm_example.webp><img alt="example p uzzle" src=algorithm_example.webp></a></div><p>For the puzzle above, the data will look like this.<pre style=background:#191919;color:#e8d4c0><code><span>empty_mask:    1101111011111111111111101111111111110111111011111111111111111101
</span><span>monster_mask:  0010000100000000000000010000000000001000000000000000000000000010
</span><span>treasure_mask: 0000000000000000000000000000000000000000000100000000000000000000
</span><span>wall_mask:     0000000000000000000000000000000000000000000000000000000000000000
</span></code></pre><p>If I wrap the bits into 8x8 grids, you can see the bits map exactly to the tile locations.<pre style=background:#191919;color:#e8d4c0><code><span>  emmpty    monster   treasure  wall
</span><span>  11011110  00100001  00000000  00000000
</span><span>  11111111  00000000  00000000  00000000
</span><span>  11111110  00000001  00000000  00000000
</span><span>  11111111  00000000  00000000  00000000
</span><span>  11110111  00001000  00000000  00000000
</span><span>  11101111  00000000  00010000  00000000
</span><span>  11111111  00000000  00000000  00000000
</span><span>  11111101  00000010  00000000  00000000
</span></code></pre><p>The task now is to figure out for what value of <code>wall_mask</code> are all the puzzle constraints satisfied? This puzzle has 58 empty tiles, so there are 2^58 or ~288 <em>quadrillion</em> ways to fill out the walls if I started with a <code>wall_mask</code> of 0 and counted up. For fun I calculated that it would take my computer ~5 years to simply count that high without doing any other work. I already knew from my combinatorial calculations earlier that I could do much better, so I focused my attention on the first row of the puzzle to figure out my approach for the recursive solution.<div class=textCenter><a class=img-link href=bit_iter_example.webp><img alt="row example" src=bit_iter_example.webp></a><div class=caption>The first row of a puzzle. It has two monsters and requires 3 walls placed among 6 empty cells.</div><br></div><p>We can see there are two monsters, leaving 6 empty cells to place 3 walls. This gives 6c3 = 20 possible wall layouts. However this ignores the <code>0</code> constraint in the 6th column indicating that there cannot be any walls there. This reduces the number of valid tiles to place walls to 5, and the number of wall permutations to 5c3 = 10. Considering the tree example from earlier, we just cut down half the tree! This demonstrates the importance of looking for early pruning opportunities in our search.<div class=textCenter><a class=img-link href=combinations.gif><img alt=combinations src=combinations.gif></a><div class=caption>The 10 possible solutions for the first row.</div><br></div><p>We can pick any of the 10 wall permutations (although it makes sense to traverse them in an order which is fast to compute) and assume it to be the correct solution for the first row of the puzzle. For each wall filled in, I subtract 1 from the vertical constraints as the number of walls remaining for that column will have now decreased. From there we move on to the next row and rinse and repeat. If we make it to the last row and haven’t violated any constraints, we will have discovered a solution to the puzzle! I say <em><strong>a</strong></em> solution instead of <em><strong>the</strong></em> solution because I can’t guarantee the puzzle generator always produces layouts with a unique solution. I therefore designed my algorithm to take this into account and push any solution it finds into a list which I can review after the search is complete. A solution only needs to encode the wall placement, so it turns out that storing the <code>wall_mask</code> wich is a <code>u64</code> is adequate. The algorithm can then be described in just a couple steps:<ul><li>Iterate over all <code>Wall</code> permutations for the current row<li>Place walls according to the current permutation<li>If we are at max depth (last row), verify that wall placements satisfy the puzzle constraints <ul><li>If the solution is valid, push it into solution vector</ul><li>Otherwise descend to the next row, recursively</ul><p>Iterating through the <code>Wall</code> permutations for a row can be described as finding all the 8-bit numbers with 3 <code>1</code> bits, and then exclude ones where the <code>1</code>s overlap with the positions of the monsters. Let me illustrate, again with the first row of the puzzle:<pre style=background:#191919;color:#e8d4c0><code><span>monster positions: 00100001
</span><span>satisfied columns: 00000100   // the 6th column requires 0 walls, so it is already complete
</span></code></pre><p>From here, we can OR these numbers together and invert the result to get a mask that show our wall candidates:<p>NOT (<code>00100001</code> OR <code>00000100</code>) = <code>11011010</code> (the 5 <code>1</code>’s correspond to potential wall placements)<p>Finally we can iterate a number <code>N</code> from 0 to 255, ANDing each number with this mask and keeping only those that result in exactly 3 bits being set. Rust has a built-in function called <code>count_ones()</code> that makes this pretty easy. Here’s what the first handful of matches look like:<table><thead><tr><th><code>N</code> (decimal)<th><code>N</code> (binary)<th><code>M</code> (N AND Mask)<tbody><tr><td>26<td>00011010<td>00011010<tr><td>27<td>00011011<td>00011010<tr><td>30<td>00011110<td>00011010<tr><td>31<td>00011111<td>00011010<tr><td>58<td>00111010<td>00011010<tr><td>59<td>00111011<td>00011010<tr><td>62<td>00111110<td>00011010<tr><td>63<td>00111111<td>00011010<tr><td>74<td>01001010<td>01001010<tr><td>75<td>01001011<td>01001010<tr><td>78<td>01001110<td>01001010<tr><td>79<td>01001111<td>01001010<tr><td>82<td>01010010<td>01010010<tr><td>83<td>01010011<td>01010010<tr><td>86<td>01010110<td>01010010<tr><td>87<td>01010111<td>01010010<tr><td>88<td>01011000<td>01011000<tr><td>89<td>01011001<td>01011000<tr><td>92<td>01011100<td>01011000<tr><td>93<td>01011101<td>01011000</table><p>There’s a small problem here, and that is that our masking function results in multiple <code>N</code>s that map to the same wall placement configuration (for example 26, 27, 30, 31, 58, 59, 62, and 63 all map to 00011010). This will result in performing the same guess multiple times and duplicating work. As a simple workaround I kept track of the last value of <code>M</code>, and if the current value is the same, skip the guess and increment <code>N</code>. This was a slight improvement, but eventually I just created a lookup table called <code>BIT_PERMUTATIONS</code> that could be indexed by the current empty cell mask and the required wall count. It returned a list with the valid masks for the current row. It looked something like this:<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#95cc5e>let</span><span> candidate_mask </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0b11011010</span><span>; </span><span style=color:#7a7267>// mask indicating potential wall positions
</span><span style=color:#95cc5e>let</span><span> walls_required </span><span style=color:#db784d>= </span><span style=color:#eaae2e>3</span><span>;          </span><span style=color:#7a7267>// number of walls required
</span><span style=color:#95cc5e>let</span><span> guesses </span><span style=color:#db784d>= BIT_PERMUTATIONS</span><span>[valid_positions][walls_required];
</span><span style=color:#7a7267>// 'guesses' is now the list of numbers with 3 of the 5 bits set from candidate mask
</span><span style=color:#7a7267>// -> [26, 74, 82, 88, 138, 146, 152, 194, 200, 208]
</span></code></pre><p>Implementing the rest of the recursive solver goes basically as you might expect. I’ll leave some annotated code here that hopefully explains itself well enough. Feel free to skip over it and just look at the results :)<p>We start with <code>depth=0</code>, representing the top row of the puzzle. Guesses are subsequently made for each row until a solution is found and pushed to the <code>solutions</code> vector. There are a few conditions that are tested to handle invalid states like a row needing more walls than it has space for.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#95cc5e>fn </span><span style=color:#60a365>solve_recursive</span><span>(
</span><span>    </span><span style=color:#db784d>&</span><span style=font-style:italic;color:#f8bb39>self</span><span>,
</span><span>    </span><span style=color:#7a7267>// The numbers along the top of the puzzle. These will be modified as walls are placed.
</span><span>    </span><span style=font-style:italic;color:#f8bb39>column_counts</span><span>: [</span><span style=color:#95cc5e>u8</span><span>; 8],
</span><span>    </span><span style=color:#7a7267>// 64 bit mask where every 1 represents an Empty tile
</span><span>    </span><span style=font-style:italic;color:#f8bb39>empty_mask</span><span>: </span><span style=color:#95cc5e>u64</span><span>,
</span><span>    </span><span style=color:#7a7267>// 64 bit mask where every 1 represents a Wall tile
</span><span>    </span><span style=font-style:italic;color:#f8bb39>wall_mask</span><span>: </span><span style=color:#95cc5e>u64</span><span>,
</span><span>    </span><span style=color:#7a7267>// Recursion depth (represents which row we are currently guessing)
</span><span>    </span><span style=font-style:italic;color:#f8bb39>depth</span><span>: </span><span style=color:#95cc5e>usize</span><span>,
</span><span>    </span><span style=color:#7a7267>// Output vector to hold any/all solutions we (hopefully) find
</span><span>    </span><span style=font-style:italic;color:#f8bb39>solutions</span><span>: </span><span style=color:#db784d>&mut </span><span style=font-style:italic;color:#db784d>Vec</span><span><</span><span style=color:#95cc5e>u64</span><span>>,
</span><span>) {
</span><span>    </span><span style=color:#7a7267>// The number of walls required by the row at the current depth
</span><span>    </span><span style=color:#95cc5e>let</span><span> row_wall_count </span><span style=color:#db784d>= </span><span style=color:#207241>self</span><span>.left_nums[depth];
</span><span>
</span><span>    </span><span style=color:#7a7267>// An 8 bit bitmask of empty cells for the current row. The call to 'to_be_bytes()'
</span><span>    </span><span style=color:#7a7267>// casts the u64 as a [u8; 8], letting me pluck out the byte I need
</span><span>    </span><span style=color:#95cc5e>let</span><span> row_empty_cells </span><span style=color:#db784d>=</span><span> empty_mask.</span><span style=color:#95cc5e>to_be_bytes</span><span>()[depth];
</span><span>
</span><span>    </span><span style=color:#7a7267>// 8 bit bitmask marking columns that are not full yet (remaining count > 0)
</span><span>    </span><span style=color:#95cc5e>let</span><span> unsatisfied_columns </span><span style=color:#db784d>=</span><span> column_counts
</span><span>        .</span><span style=color:#95cc5e>into_iter</span><span>()
</span><span>        .</span><span style=color:#95cc5e>map</span><span>(|</span><span style=font-style:italic;color:#f8bb39>i</span><span>| </span><span style=color:#db784d>if</span><span> i </span><span style=color:#db784d>> </span><span style=color:#eaae2e>0 </span><span>{ </span><span style=color:#eaae2e>1</span><span style=color:#95cc5e>u8 </span><span>} </span><span style=color:#db784d>else </span><span>{ </span><span style=color:#eaae2e>0 </span><span>})
</span><span>        .</span><span style=color:#95cc5e>fold</span><span>(</span><span style=color:#eaae2e>0</span><span>, |</span><span style=font-style:italic;color:#f8bb39>acc</span><span>, </span><span style=font-style:italic;color:#f8bb39>x</span><span>| (acc </span><span style=color:#db784d><< </span><span style=color:#eaae2e>1</span><span>) </span><span style=color:#db784d>+</span><span> x);
</span><span>
</span><span>    </span><span style=color:#7a7267>// Final mask for the row is 'empty cells that have not yet met their vertical constraint'
</span><span>    </span><span style=color:#95cc5e>let</span><span> valid_positions_mask </span><span style=color:#db784d>=</span><span> row_empty_cells </span><span style=color:#db784d>&</span><span> unsatisfied_columns;
</span><span>
</span><span>    </span><span style=color:#db784d>if</span><span> valid_positions_mask.</span><span style=color:#95cc5e>count_ones</span><span>() </span><span style=color:#db784d><</span><span> row_wall_count </span><span style=color:#db784d>as </span><span style=color:#95cc5e>u32 </span><span>{
</span><span>        </span><span style=color:#7a7267>// The row requires more walls than there are valid positions, return early
</span><span>        </span><span style=color:#db784d>return</span><span>;
</span><span>    } </span><span style=color:#db784d>else if</span><span> depth </span><span style=color:#db784d>== </span><span style=color:#eaae2e>7 </span><span style=color:#db784d>&&</span><span> valid_positions_mask.</span><span style=color:#95cc5e>count_ones</span><span>() </span><span style=color:#db784d>!=</span><span> row_wall_count </span><span style=color:#db784d>as </span><span style=color:#95cc5e>u32 </span><span>{
</span><span>        </span><span style=color:#7a7267>// We're on the last row and we don't have exactly as many valid positions as walls
</span><span>        </span><span style=color:#7a7267>// to place, return early (final row must result in ALL constraints satisfied)
</span><span>        </span><span style=color:#db784d>return</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#7a7267>// Iterate through all possible 8 bit masks, starting with 0b00000001 until it wraps back to 0
</span><span>    </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> candidate_mask </span><span style=color:#db784d>= </span><span style=color:#eaae2e>1</span><span style=color:#95cc5e>u8</span><span>;
</span><span>    </span><span style=color:#db784d>while</span><span> candidate_mask </span><span style=color:#db784d>!= </span><span style=color:#eaae2e>0 </span><span>{
</span><span>        </span><span style=color:#7a7267>// Skip this mask if it would place a wall on an invalid tile
</span><span>        </span><span style=color:#db784d>if !</span><span>valid_positions_mask </span><span style=color:#db784d>&</span><span> candidate_mask </span><span style=color:#db784d>!= </span><span style=color:#eaae2e>0 </span><span>{
</span><span>            candidate_mask </span><span style=color:#db784d>=</span><span> candidate_mask.</span><span style=color:#95cc5e>wrapping_add</span><span>(</span><span style=color:#eaae2e>1</span><span>);
</span><span>            </span><span style=color:#db784d>continue</span><span>;
</span><span>        }
</span><span>        </span><span style=color:#7a7267>// Only consider masks that will place the number of walls required
</span><span>        </span><span style=color:#db784d>if</span><span> candidate_mask.</span><span style=color:#95cc5e>count_ones</span><span>() </span><span style=color:#db784d>==</span><span> row_wall_count </span><span style=color:#db784d>as </span><span style=color:#95cc5e>u32 </span><span>{
</span><span>            </span><span style=color:#7a7267>// Place the walls by OR'ing the candidate mask into the wall mask
</span><span>            </span><span style=color:#95cc5e>let</span><span> wall_mask </span><span style=color:#db784d>=</span><span> wall_mask </span><span style=color:#db784d>| </span><span>(candidate_mask </span><span style=color:#db784d>as </span><span style=color:#95cc5e>u64</span><span>) </span><span style=color:#db784d><< </span><span>(</span><span style=color:#eaae2e>56 </span><span style=color:#db784d>- </span><span style=color:#eaae2e>8 </span><span style=color:#db784d>*</span><span> depth);
</span><span>            </span><span style=color:#95cc5e>let</span><span> empty_mask </span><span style=color:#db784d>=</span><span> empty_mask </span><span style=color:#db784d>& !</span><span>wall_mask;
</span><span>
</span><span>            </span><span style=color:#7a7267>// Update the vertical counts (subtract 1 from each column where a wall was placed)
</span><span>            </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> counts </span><span style=color:#db784d>=</span><span> column_counts.</span><span style=color:#95cc5e>clone</span><span>();
</span><span>            </span><span style=color:#db784d>for</span><span> i </span><span style=color:#db784d>in </span><span style=color:#eaae2e>0</span><span style=color:#db784d>..</span><span style=color:#eaae2e>8 </span><span>{
</span><span>                </span><span style=color:#db784d>if </span><span>(candidate_mask </span><span style=color:#db784d>& </span><span>(</span><span style=color:#eaae2e>1 </span><span style=color:#db784d><< </span><span>(</span><span style=color:#eaae2e>7 </span><span style=color:#db784d>-</span><span> i))) </span><span style=color:#db784d>>= </span><span style=color:#eaae2e>1 </span><span>{
</span><span>                    counts[i] </span><span style=color:#db784d>-= </span><span style=color:#eaae2e>1</span><span>;
</span><span>                }
</span><span>            }
</span><span>
</span><span>            </span><span style=color:#7a7267>// If we've reached the last row and haven't returned early, the current wall mask
</span><span>            </span><span style=color:#7a7267>// represents a candidate solution. Check it's validity and push to solution vector
</span><span>            </span><span style=color:#db784d>if</span><span> depth </span><span style=color:#db784d>== </span><span style=color:#eaae2e>7 </span><span>{
</span><span>                </span><span style=color:#db784d>if </span><span style=color:#95cc5e>is_valid_solution</span><span>(empty_mask, </span><span style=color:#207241>self</span><span>.monster_mask, </span><span style=color:#207241>self</span><span>.treasure_mask) {
</span><span>                    </span><span style=color:#95cc5e>let</span><span> sol </span><span style=color:#db784d>=</span><span> wall_mask;
</span><span>                    solutions.</span><span style=color:#95cc5e>push</span><span>(sol);
</span><span>                }
</span><span>            } </span><span style=color:#db784d>else </span><span>{
</span><span>                </span><span style=color:#207241>self</span><span>.</span><span style=color:#95cc5e>solve_recursive</span><span>(
</span><span>                    counts,
</span><span>                    empty_mask,
</span><span>                    wall_mask,
</span><span>                    depth </span><span style=color:#db784d>+ </span><span style=color:#eaae2e>1</span><span>,
</span><span>                    solutions,
</span><span>                );
</span><span>            }
</span><span>        }
</span><span>        candidate_mask </span><span style=color:#db784d>=</span><span> candidate_mask.</span><span style=color:#95cc5e>wrapping_add</span><span>(</span><span style=color:#eaae2e>1</span><span>);
</span><span>    }
</span><span>}
</span></code></pre><p>I snuck in a call to <code>is_valid_solution()</code> there, which I haven’t yet implemented. For now I’ll just return true to see if the recursion/mask iteration is functional. I will also need a way to simulate entering the solution back into the game, so I added these functions to <code>DungeonCrawler</code>:<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span>    </span><span style=color:#7a7267>// Maps tile indices (0-7) to pixel coordinates for clicking
</span><span>    </span><span style=color:#db784d>pub </span><span style=color:#95cc5e>fn </span><span style=color:#60a365>place_wall</span><span>(</span><span style=color:#db784d>&mut </span><span style=font-style:italic;color:#f8bb39>self</span><span>, </span><span style=font-style:italic;color:#f8bb39>x</span><span>: </span><span style=color:#95cc5e>u8</span><span>, </span><span style=font-style:italic;color:#f8bb39>y</span><span>: </span><span style=color:#95cc5e>u8</span><span>) -> </span><span style=font-style:italic;color:#db784d>Result</span><span><()> {
</span><span>        </span><span style=color:#207241>self</span><span>.</span><span style=color:#95cc5e>click</span><span>(
</span><span>            x </span><span style=color:#db784d>as </span><span style=color:#95cc5e>u32 </span><span style=color:#db784d>* TILE_STRIDE + TILE_BASE</span><span>.</span><span style=color:#eaae2e>0</span><span>,
</span><span>            y </span><span style=color:#db784d>as </span><span style=color:#95cc5e>u32 </span><span style=color:#db784d>* TILE_STRIDE + TILE_BASE</span><span>.</span><span style=color:#eaae2e>1</span><span>,
</span><span>        )
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#7a7267>// Loop over each bit in the solution, click the tiles where walls are needed
</span><span>    </span><span style=color:#db784d>pub </span><span style=color:#95cc5e>fn </span><span style=color:#60a365>enter_solution</span><span>(</span><span style=color:#db784d>&mut </span><span style=font-style:italic;color:#f8bb39>self</span><span>, </span><span style=font-style:italic;color:#f8bb39>solution</span><span>: </span><span style=color:#95cc5e>u64</span><span>) -> </span><span style=font-style:italic;color:#db784d>Result</span><span><()> {
</span><span>        println!(</span><span style=color:#eaae2e>"</span><span style=color:#db784d>{solution}</span><span style=color:#eaae2e>"</span><span>);
</span><span>        </span><span style=color:#db784d>for</span><span> i </span><span style=color:#db784d>in </span><span style=color:#eaae2e>0</span><span style=color:#db784d>..</span><span style=color:#eaae2e>64 </span><span>{
</span><span>            </span><span style=color:#95cc5e>let</span><span> y </span><span style=color:#db784d>=</span><span> i </span><span style=color:#db784d>/ </span><span style=color:#eaae2e>8</span><span>;
</span><span>            </span><span style=color:#95cc5e>let</span><span> x </span><span style=color:#db784d>=</span><span> i </span><span style=color:#db784d>% </span><span style=color:#eaae2e>8</span><span>;
</span><span>            </span><span style=color:#db784d>if</span><span> solution </span><span style=color:#db784d>& </span><span>(</span><span style=color:#eaae2e>1 </span><span style=color:#db784d><< </span><span>(</span><span style=color:#eaae2e>63 </span><span style=color:#db784d>-</span><span> i)) </span><span style=color:#db784d>!= </span><span style=color:#eaae2e>0 </span><span>{
</span><span>                </span><span style=color:#207241>self</span><span>.</span><span style=color:#95cc5e>place_wall</span><span>(x, y)</span><span style=color:#db784d>?</span><span>;
</span><span>            }
</span><span>        }
</span><span>        </span><span style=color:#7a7267>// Aleep a brief moment in case we are solving multiple puzzles quickly to not miss inputs
</span><span>        thread::sleep(Duration::from_millis(</span><span style=color:#eaae2e>10</span><span>));
</span><span>        </span><span style=font-style:italic;color:#db784d>Ok</span><span>(())
</span><span>    }
</span></code></pre><p>And lastly I could put together the main solve loop, which will continuously parse puzzles, solve them, and enter the solution back into the game. I added the solve time to the output as well as the puzzle seed and number of solutions found so I could revisit puzzles if I needed to debug anything. I added an escape if multiple solutions were found to just generate a new puzzle.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span>
</span><span style=color:#95cc5e>fn </span><span style=color:#60a365>solve_loop</span><span>() -> </span><span style=font-style:italic;color:#db784d>Result</span><span><()> {
</span><span>    </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> dc </span><span style=color:#db784d>= </span><span>dungeon_crawler::DungeonCrawler::new()</span><span style=color:#db784d>?</span><span>;
</span><span>
</span><span>    </span><span style=color:#db784d>loop </span><span>{
</span><span>        </span><span style=color:#95cc5e>let</span><span> t0 </span><span style=color:#db784d>= </span><span>Instant::now(); </span><span style=color:#7a7267>// For measuring solve time
</span><span>        </span><span style=color:#95cc5e>let</span><span> puzzle </span><span style=color:#db784d>=</span><span> dc.</span><span style=color:#95cc5e>parse</span><span>()</span><span style=color:#db784d>?</span><span>;
</span><span>        </span><span style=color:#95cc5e>let</span><span> bt </span><span style=color:#db784d>= </span><span>solve::Backtracker::new(</span><span style=color:#db784d>&</span><span>puzzle);
</span><span>        </span><span style=color:#95cc5e>let</span><span> solutions </span><span style=color:#db784d>=</span><span> bt.</span><span style=color:#95cc5e>solve</span><span>();
</span><span>
</span><span>        </span><span style=color:#95cc5e>let</span><span> time </span><span style=color:#db784d>= </span><span>format!(</span><span style=color:#eaae2e>"</span><span style=color:#db784d>{:.2}</span><span style=color:#eaae2e>s"</span><span>, t0.</span><span style=color:#95cc5e>elapsed</span><span>().</span><span style=color:#95cc5e>as_secs_f32</span><span>());
</span><span>
</span><span>        print!(</span><span style=color:#eaae2e>"seed: </span><span style=color:#db784d>{:0>8}</span><span style=color:#eaae2e> - "</span><span>, puzzle.seed.</span><span style=color:#95cc5e>unwrap</span><span>());
</span><span>        </span><span style=color:#db784d>match</span><span> solutions.</span><span style=color:#95cc5e>len</span><span>() {
</span><span>            </span><span style=color:#eaae2e>0 </span><span style=color:#db784d>=> </span><span>println!(</span><span style=color:#eaae2e>" no solution found in </span><span style=color:#db784d>{time}</span><span style=color:#eaae2e>"</span><span>),
</span><span>            </span><span style=color:#eaae2e>1 </span><span style=color:#db784d>=> </span><span>{
</span><span>                println!(</span><span style=color:#eaae2e>"unique solution found in </span><span style=color:#db784d>{time}</span><span style=color:#eaae2e>"</span><span>);
</span><span>                dc.</span><span style=color:#95cc5e>enter_solution</span><span>(</span><span style=color:#db784d>*</span><span>solutions.</span><span style=color:#95cc5e>last</span><span>().</span><span style=color:#95cc5e>unwrap</span><span>()).</span><span style=color:#95cc5e>unwrap</span><span>();
</span><span>                </span><span style=color:#7a7267>// Give the game time to process the solution being entered
</span><span>                thread::sleep(Duration::from_millis(</span><span style=color:#eaae2e>25</span><span>));
</span><span>            }
</span><span>            </span><span style=color:#db784d>_ => </span><span>{
</span><span>                println!(</span><span style=color:#eaae2e>" </span><span style=color:#db784d>{: >3}</span><span style=color:#eaae2e> solutions found in </span><span style=color:#db784d>{time}</span><span style=color:#eaae2e>"</span><span>, solutions.</span><span style=color:#95cc5e>len</span><span>());
</span><span>            }
</span><span>        }
</span><span>
</span><span>        </span><span style=color:#7a7267>// Go to the next puzzle
</span><span>        dc.</span><span style=color:#95cc5e>random_board</span><span>()
</span><span>    }
</span><span>
</span><span>    </span><span style=font-style:italic;color:#db784d>Ok</span><span>(())
</span><span>}
</span></code></pre><p>Surprisingly, this kind of worked on the first attempt. Letting it run for a while, the output looked like this:<pre style=background:#191919;color:#e8d4c0><code><span>seed: 33095486 - 4720 solutions found in 0.09s
</span><span>seed: 94075043 - 48 solutions found in 0.10s
</span><span>seed: 87234007 - 11 solutions found in 0.01s
</span><span>seed: 45151188 - 7936 solutions found in 0.46s
</span><span>seed: 49329791 - 672 solutions found in 1.11s
</span><span>seed: 49074641 - 2 solutions found in 0.00s
</span><span>seed: 91524114 - 8 solutions found in 0.23s
</span><span>seed: 16324322 - 10816 solutions found in 0.90s
</span><span>seed: 69331359 - 21040 solutions found in 2.77s
</span><span>seed: 18835572 - 32 solutions found in 0.75s
</span><span>seed: 22819008 - 912 solutions found in 0.26s
</span><span>seed: 93365886 - 4 solutions found in 0.08s
</span><span>seed: 60424626 - 27600 solutions found in 3.45s
</span><span>seed: 74146725 - 184 solutions found in 0.04s
</span><span>seed: 10221255 - 64 solutions found in 1.02s
</span><span>seed: 17959478 - 1216 solutions found in 0.39s
</span><span>seed: 63973204 - 1376 solutions found in 0.04s
</span><span>seed: 46593034 - 608 solutions found in 0.67s
</span><span>seed: 17089073 - 128 solutions found in 0.01s
</span><span>seed: 14192672 - 1488 solutions found in 0.74s
</span></code></pre><p>This looked promising performance-wise, with most solves being under 1 second, but I was unable to find any unique solutions. Running it on a 10000 puzzles from my puzzle database gave some more insight into how much work is left to do:<ul><li>The vast majority of puzzles are solved in under 1 second, but some take over 30 seconds and 2 of them were over 5 minutes<li>No unique solutions were found at all</ul><p>To be honest this is not really surprising considering I’ve only set out to satisfy constraint #1 so far (horizontal and vertical wall counts) while ignoring the other 5. This lead to solutions like these:<div class=textCenter><a class=img-link href=bad_solutions.webp><img alt="bad solutions" src=bad_solutions.webp></a><div class=caption>Two 'solutions' with correct wall counts but several other constraints being violated.</div><br></div><p>If you count the number of walls in each row and column they will be correct, but all 5 other constraints are violated. I’ll reiterate them quickly here - We have treasure rooms that are not 3x3, treasure rooms with more than one exit, hallways that are 2x2, monsters that are not in a dead end, and lastly a path that is not a single contiguous block. Let’s see if we can do better.<h1 id=correctness-and-performance-improvements>Correctness and Performance Improvements</h1><p>One thing that stood out in the “solutions” above was just how <em>bad</em> it was at placing walls around the treasure chests. In retrospect this should have been an obvious failure case for my approach because rooms have a well-defined structure over a 5x5 area (3x3 room surrounded by mostly walls) and I was haphazardly rolling dice to guess where the walls go. This has a worst-case probability of (1/2)^25, or about 1 in 33 million. I knew I could do better if I was clever about it. Since the rooms dominate a large area of the board, I thought perhaps I could precompute the valid treasure room positions ahead of time, and use those layouts as starting points for the solver.</p><center> <video onclick="this.paused ? this.play() : this.pause();" alt=rooms autoplay loop src=treasure_rooms.webm></video> <div class=caption>Given two treasure chests, there are only 4 valid ways to place two treasure rooms. Rooms can neither touch monsters nor other rooms.</div> </center><p>Given the 4 room layouts above I can invoke the recursive solver 4 times, each time using the blue regions as a mask to exclude wall placement. If the rooms are not in the true location, it will likely cause the solver to terminate much faster.<p>Revisiting the 15 puzzles above, our results now look like this:<pre style=background:#191919;color:#e8d4c0><code><span>seed: 33095486 - 12 solutions found in 0.00s
</span><span>seed: 94075043 - 4 solutions found in 0.00s
</span><span>seed: 87234007 - 4 solutions found in 0.00s
</span><span>seed: 45151188 - 18 solutions found in 0.00s
</span><span>seed: 49329791 - 9 solutions found in 0.01s
</span><span>seed: 49074641 - unique solution found in 0.00s
</span><span>seed: 91524114 - unique solution found in 0.01s
</span><span>seed: 16324322 - 44 solutions found in 0.01s
</span><span>seed: 69331359 - 693 solutions found in 0.06s
</span><span>seed: 18835572 - 3 solutions found in 0.01s
</span><span>seed: 22819008 - 4 solutions found in 0.00s
</span><span>seed: 93365886 - unique solution found in 0.00s
</span><span>seed: 60424626 - 823 solutions found in 0.04s
</span><span>seed: 74146725 - 8 solutions found in 0.00s
</span><span>seed: 10221255 - unique solution found in 0.02s
</span><span>seed: 17959478 - 3 solutions found in 0.01s
</span><span>seed: 63973204 - 31 solutions found in 0.00s
</span><span>seed: 46593034 - 10 solutions found in 0.01s
</span><span>seed: 17089073 - 3 solutions found in 0.00s
</span><span>seed: 14192672 - 38 solutions found in 0.01s
</span></code></pre><p>Huge success! I was now finding a handful of unique solutions, and the solve speed was maybe 2 orders of magnitude faster. Running it on 10000 puzzles completed in just under 4 seconds. In order to cut down on the cases with multiple solutions, I had to start intelligently checking whether my solutions actually met all the constraints. I planned to do this with a series of predicates, one per constraint, relying mostly on bitwise math to remain performant. The checker would look something like this:<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#7a7267>// Chaining these calls together with && allows short-circuit evaluation, meaning the
</span><span style=color:#7a7267>// slowest predicates will only be tested if necessary
</span><span style=color:#95cc5e>fn </span><span style=color:#60a365>is_valid_solution</span><span>(</span><span style=font-style:italic;color:#f8bb39>empty_mask</span><span>: </span><span style=color:#95cc5e>u64</span><span>, </span><span style=font-style:italic;color:#f8bb39>features</span><span>: </span><span style=color:#db784d>&</span><span>PuzzleFeatures) -> </span><span style=color:#95cc5e>bool </span><span>{
</span><span>    </span><span style=color:#95cc5e>no_wide_hallways</span><span>(empty_mask, features)
</span><span>    </span><span style=color:#db784d>&& </span><span style=color:#95cc5e>check_treasure_rooms</span><span>(empty_mask, features)
</span><span>    </span><span style=color:#db784d>&& </span><span style=color:#95cc5e>dead_ends_have_monsters</span><span>(empty_mask, features)
</span><span>    </span><span style=color:#db784d>&& </span><span style=color:#95cc5e>contiguous_path</span><span>(empty_mask, features)
</span><span>}
</span></code></pre><p>I added a parameter of type <code>PuzzleFeatures</code> which is just a collection of unchanging features of the puzzle that are useful in constraint evaluation. <code>empty_mask</code> is a bitmask identifying empty cells, which constantly changes as guesses are made. The <code>PuzzleFeatures</code> struct has 5 members:<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#95cc5e>struct </span><span>PuzzleFeatures {
</span><span>    </span><span style=color:#7a7267>/// Constraints on the left side of the puzzle
</span><span>    </span><span style=color:#f8bb39>left_nums</span><span>: [</span><span style=color:#95cc5e>u8</span><span>; 8],
</span><span>    </span><span style=color:#7a7267>/// Bitmask of monster locations
</span><span>    </span><span style=color:#f8bb39>monster_mask</span><span>: </span><span style=color:#95cc5e>u64</span><span>,
</span><span>    </span><span style=color:#7a7267>/// Bitmask of treasure locations
</span><span>    </span><span style=color:#f8bb39>treasure_mask</span><span>: </span><span style=color:#95cc5e>u64</span><span>,
</span><span>    </span><span style=color:#7a7267>/// Bitmask of 3x3 treasure rooms
</span><span>    </span><span style=color:#f8bb39>rooms_mask</span><span>: </span><span style=color:#95cc5e>u64</span><span>,
</span><span>    </span><span style=color:#7a7267>/// List of (x, y) coordinates for treasure chests (blue regions from the gif above)
</span><span>    </span><span style=color:#f8bb39>room_positions</span><span>: </span><span style=font-style:italic;color:#db784d>Vec</span><span><(</span><span style=color:#95cc5e>u8</span><span>, </span><span style=color:#95cc5e>u8</span><span>)>,
</span><span>}
</span></code></pre><p>Let’s see what we can do with these values. I’ll walk you through the implementation for each of the predicates.<p>—– 1. No Wide Hallways —–<p>Detecting wide hallways (2x2 or larger section of <code>Empty</code> tiles) is pretty easy with bitwise math. We just look at each empty tile and check if the tiles to the east, south, and southeast are also empty. Checking the neighbors can be done quickly by bitshifting the <code>empty_mask</code>. A shift by 1 bit will access neighbors left/right, whereas a shift by 8 bits will access neighbors above/below. There is one small edge case (literally) to handle, and that is that bits on the left and right edge will assume they are adjacent to one another, as I will try to demonstrate visually (this was hard to visualize):<div class=textCenter><a class=img-link href=bitshifts.webp><img alt="bit indices" src=bitshifts.webp></a><div class=caption>Left: bit indices. Middle: shifting by one bit accesses the horizontal neighbors. Right: shifting by 8 bits accesses vertical neighbors.</div><br></div><p>To compensate for this faux-adjacency, we can further mask the leftmost and rightmost columns when doing left and right shifts. The least significant bit corresponds to the bottom right tile, increasing first to the left and then vertically. The most significant bit represents the top left bit. In red I’ve highlighted the bits that either wrap around the board, or get shifted in as 0s. Knowing this, I created a few more masks which I can use to ignore those bits.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#7a7267>// masks to hide bits that wrapped around the edge of the board
</span><span style=color:#95cc5e>const </span><span style=color:#db784d>LEFTSHIFT_MASK</span><span>: </span><span style=color:#95cc5e>u64 </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0xfefefefefefefefe</span><span>;
</span><span style=color:#95cc5e>const </span><span style=color:#db784d>RIGHTSHIFT_MASK</span><span>: </span><span style=color:#95cc5e>u64 </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0x7f7f7f7f7f7f7f7f</span><span>;
</span><span>
</span><span style=color:#95cc5e>fn </span><span style=color:#60a365>no_wide_hallways</span><span>(</span><span style=font-style:italic;color:#f8bb39>empty_mask</span><span>: </span><span style=color:#95cc5e>u64</span><span>, </span><span style=font-style:italic;color:#f8bb39>features</span><span>: </span><span style=color:#db784d>&</span><span>PuzzleFeatures) -> </span><span style=color:#95cc5e>bool </span><span>{
</span><span>    </span><span style=color:#7a7267>// Create a bitmask indicating cells that are part of a 2x2 Empty region
</span><span>    </span><span style=color:#7a7267>// Check cell to the East, ignoring bits that wrap around the board
</span><span>    </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> wide_hall_mask </span><span style=color:#db784d>=</span><span> empty_mask </span><span style=color:#db784d>& </span><span>((empty_mask </span><span style=color:#db784d><< </span><span style=color:#eaae2e>1</span><span>) </span><span style=color:#db784d>& LEFTSHIFT_MASK</span><span>);
</span><span>    </span><span style=color:#7a7267>// Check cell to the South and Southeast
</span><span>    wide_hall_mask </span><span style=color:#db784d>&=</span><span> wide_hall_mask </span><span style=color:#db784d><< </span><span style=color:#eaae2e>8</span><span>;
</span><span>    </span><span style=color:#7a7267>// Check cell to the West
</span><span>    wide_hall_mask </span><span style=color:#db784d>|= </span><span>(wide_hall_mask </span><span style=color:#db784d>>> </span><span style=color:#eaae2e>1</span><span>) </span><span style=color:#db784d>& RIGHTSHIFT_MASK</span><span>;
</span><span>    </span><span style=color:#7a7267>// Check cell to the North and Northwest
</span><span>    wide_hall_mask </span><span style=color:#db784d>|=</span><span> wide_hall_mask </span><span style=color:#db784d>>> </span><span style=color:#eaae2e>8</span><span>;
</span><span>
</span><span>    </span><span style=color:#7a7267>// At this point, all the 1s in the mask are part of 2x2 or larger Empty regions
</span><span>    </span><span style=color:#7a7267>// Need to ignore bits that are part of a treasure room (2x2 Empty is legal there)
</span><span>    wide_hall_mask </span><span style=color:#db784d>& !</span><span>features.room_mask </span><span style=color:#db784d>== </span><span style=color:#eaae2e>0
</span><span>}
</span></code></pre><p>This solution is <em>wicked</em> fast. The bitwise math allows us to operate on all 64 tiles at once with no need for looping or array indexing. I later learned this is referred to as <a href=https://en.wikipedia.org/wiki/SWAR rel=noopener target=_blank>SIMD Within a Register (SWAR)</a>.<p>—– 2. Monsters in Dead Ends —–<p>The condtion we need to evaluate is “Monsters have exactly 1 <code>Empty</code> tile adjacent to them”. I put together a boolean function to do this similar to the wide hallway detection, but it is slightly more involved. My implementation is fast, but I suspect a more efficient method exists.<p>—– 3. Treasure Rooms have 1 Entrance —–<p>I thought about this one for a while - and initially planned to loop over the 16 tiles surrounding each 3x3 treasure room and count the <code>Empty</code> tiles. This worked but I was itching for another cute SWAR solution using bitmath. I figured I could create a mask of the treasure room boundary and multiply it with the <code>Empty</code> tile mask. I can assert that the result has a single <code>1</code> bit to prove that the room has exactly one entrance.<div class=textCenter><a class=img-link href=treasure_room_mask.webp><img alt="treasure room boundary bitmask" src=treasure_room_mask.webp></a><div class=caption>The red pixels indicate the boundary of one of the potential treasure room positions. Exactly one of the red tiles needs to be Empty</div><br></div><p>In the image above, I have chosen a potential spot for the treasure room in blue. The 12 red boundary tiles are what I want to create a mask of. Reading the bits out in a grid looks like this:<pre style=background:#191919;color:#e8d4c0><code><span>00001110
</span><span>00010001
</span><span>00010001
</span><span>00010001
</span><span>00001110
</span><span>00000000
</span><span>00000000
</span><span>00000000
</span></code></pre><p>And converting that to a u64: <code>0b0000111000010001000100010001000100001110000000000000000000000000</code> (or <code>0x0E1111110E000000</code> in hexidecimal)<p>I built up a table of these masks, one for each of the 36 potential treasure room locations (3x3 room can only fit in an 8x8 grid 36 ways), and I can look it up based on the room location.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#95cc5e>fn </span><span style=color:#60a365>check_treasure_rooms</span><span>(</span><span style=font-style:italic;color:#f8bb39>empty_mask</span><span>: </span><span style=color:#95cc5e>u64</span><span>, </span><span style=font-style:italic;color:#f8bb39>features</span><span>: </span><span style=color:#db784d>&</span><span>PuzzleFeatures) -> </span><span style=color:#95cc5e>bool </span><span>{
</span><span>    </span><span style=color:#7a7267>// Loop over each treasure room
</span><span>    </span><span style=color:#db784d>for &</span><span>(x, y) </span><span style=color:#db784d>in</span><span> features.room_positions.</span><span style=color:#95cc5e>iter</span><span>() {
</span><span>        </span><span style=color:#7a7267>// Multiply the boundary mask with the empty mask and count the 1s
</span><span>        </span><span style=color:#db784d>if </span><span>(empty_mask </span><span style=color:#db784d>& ROOM_BORDER_MASKS</span><span>[y </span><span style=color:#db784d>as </span><span style=color:#95cc5e>usize</span><span>][x </span><span style=color:#db784d>as </span><span style=color:#95cc5e>usize</span><span>]).</span><span style=color:#95cc5e>count_ones</span><span>() </span><span style=color:#db784d>!= </span><span style=color:#eaae2e>1 </span><span>{
</span><span>            </span><span style=color:#db784d>return false</span><span>;
</span><span>        }
</span><span>    }
</span><span>    </span><span style=color:#db784d>true
</span><span>}
</span></code></pre><p>—– 4. Contiguous Path —–<p>I saved the worst for last. Checking if the entire path is contiguous boils down to a floodfill algorithm which is hard to do without a iterating. I can strategically do this check last so it only happens if all the other conditions are satisfied, meaning it should be called as infrequently as possible. I implemented it by performing iterative <a href=https://en.wikipedia.org/wiki/Dilation_(morphology) rel=noopener target=_blank>dilation</a> starting from a single <code>Empty</code> tile and repeating until no change is detected. If the number of <code>1</code>s in the flooded region is equal to the number of <code>Empty</code> + <code>Treasure</code> + <code>Monster</code> tiles (treasure and monsters can be considered part of the path).<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#95cc5e>fn </span><span style=color:#60a365>contiguous_path</span><span>(</span><span style=font-style:italic;color:#f8bb39>empty_mask</span><span>: </span><span style=color:#95cc5e>u64</span><span>, </span><span style=font-style:italic;color:#f8bb39>features</span><span>: </span><span style=color:#db784d>&</span><span>PuzzleFeatures) -> </span><span style=color:#95cc5e>bool </span><span>{
</span><span>    </span><span style=color:#7a7267>// Create the initial flood mask by only setting the first 1 bit from the Empty mask
</span><span>    </span><span style=color:#95cc5e>let</span><span> tz </span><span style=color:#db784d>=</span><span> empty_mask.</span><span style=color:#95cc5e>trailing_zeros</span><span>();
</span><span>    </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> flood_mask </span><span style=color:#db784d>= </span><span style=color:#eaae2e>1</span><span style=color:#95cc5e>u64 </span><span style=color:#db784d><<</span><span> tz;
</span><span>
</span><span>    </span><span style=color:#7a7267>// Bitmask of region to flood includes treasure/monsters
</span><span>    </span><span style=color:#95cc5e>let</span><span> e_mask </span><span style=color:#db784d>=</span><span> empty_mask </span><span style=color:#db784d>|</span><span> features.treasure_mask </span><span style=color:#db784d>|</span><span> features.monster_mask;
</span><span>    </span><span style=color:#db784d>loop </span><span>{
</span><span>        </span><span style=color:#7a7267>// Create copy of flood mask so we can detect if anything changed
</span><span>        </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> flood_mask2 </span><span style=color:#db784d>=</span><span> flood_mask;
</span><span>        </span><span style=color:#7a7267>// Check if N,E,S,W neighbors are empty and dilate the mask appropriately
</span><span>        flood_mask2 </span><span style=color:#db784d>|= </span><span>((flood_mask </span><span style=color:#db784d><< </span><span style=color:#eaae2e>1</span><span>) </span><span style=color:#db784d>& LEFTSHIFT_MASK</span><span>) </span><span style=color:#db784d>&</span><span> e_mask;
</span><span>        flood_mask2 </span><span style=color:#db784d>|= </span><span>((flood_mask2 </span><span style=color:#db784d>>> </span><span style=color:#eaae2e>1</span><span>) </span><span style=color:#db784d>& RIGHTSHIFT_MASK</span><span>) </span><span style=color:#db784d>&</span><span> e_mask;
</span><span>        flood_mask2 </span><span style=color:#db784d>|= </span><span>(flood_mask2 </span><span style=color:#db784d><< </span><span style=color:#eaae2e>8</span><span>) </span><span style=color:#db784d>&</span><span> e_mask;
</span><span>        flood_mask2 </span><span style=color:#db784d>|= </span><span>(flood_mask2 </span><span style=color:#db784d>>> </span><span style=color:#eaae2e>8</span><span>) </span><span style=color:#db784d>&</span><span> e_mask;
</span><span>        </span><span style=color:#7a7267>// If no change occurred, we're done!
</span><span>        </span><span style=color:#db784d>if</span><span> flood_mask2 </span><span style=color:#db784d>==</span><span> flood_mask {
</span><span>            </span><span style=color:#db784d>break</span><span>;
</span><span>        }
</span><span>        flood_mask </span><span style=color:#db784d>=</span><span> flood_mask2;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#7a7267>// Check that dilated region is equal in size to the original count of Empty tiles
</span><span>    </span><span style=color:#db784d>if</span><span> flood_mask.</span><span style=color:#95cc5e>count_ones</span><span>() </span><span style=color:#db784d>!=</span><span> e_mask.</span><span style=color:#95cc5e>count_ones</span><span>() {
</span><span>        </span><span style=color:#db784d>return false</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#db784d>true
</span><span>}
</span></code></pre><p>This method expands once in each direction every step of the loop. It could probably be made faster (empirically, not algorithimcally) by starting the search near the center of the board rather than just “the first <code>Empty</code> cell we can find”, approximately reducing the number of steps by 2. I found this optimization was not needed.</p><center> <video onclick="this.paused ? this.play() : this.pause();" alt=floodfill autoplay loop src=floodfill.webm></video> <div class=caption>Floodfill/dilation process over 17 iterations</div> </center><p>In the animation above, you can see the search starts in the first <code>Empty</code> cell on the bottom row. Due to the use of <code>trailing_zeros</code> to find this cell, it will by nature be in the bottom-most row and as far to the right as possible.<p>This animation was fun to make and I hope it’s fun to watch. Now after entirely too much ado, I could finally taste the fruits of my labour.</p><center> <video onclick="this.paused ? this.play() : this.pause();" alt=guesses autoplay loop src=guesses.webm></video> <div class=caption>The 316 guesses required to solve this puzzle.</div> </center><p>I generated a gif of the solver showing each of the guesses it makes as it progresses through the puzzle. It was immensely satisfying to see this for the first time, and also caught my eye with another optimization opportunity. You can see for the first 2-3 seconds of this gif show the top-right skeleton fully surrounded by walls, which is illegal. The fix was simple, and it was to apply the “monsters in dead ends” predicate after each guess instead of only upon reaching the bottom row. This (along with the “no wide hallways” predicate) <em>massively</em> pruned the search tree and resulted in an overall speedup of over an order of magnitude.<h1 id=results>Results</h1><p>I tested the solver on my database of nearly 6 million puzzles that I parsed from the game. I was able to solve the entire corpus in under 4 seconds (parallelized across 16 threads) which implies an average single-threaded solve time of about 10 microseconds per puzzle. This was MUCH faster than I had hoped to achieve when I started this project and I was very excited to see that. Lastly, please enjoy a recording of the solver chugging through puzzles at lightspeed.</p><center> <video alt="finished product" onclick="this.paused ? this.play() : this.pause();" autoplay loop src=final.webm></video> <div class=caption>A recording of the finished program running through 20 puzzles.</div> </center><p>I like seeing the mouse cursor jump around from tile to tile, hammering home the somewhat melancholy reality that I have just spent dozens of hours writing a computer program to automate the process of having fun and documenting it for the handful of people who may one day stumble upon this.<h1 id=conclusion>Conclusion</h1><p>I’m really pleased with the outcome of this solver and had a blast writing it. I would love to come back and take a stab at generating my own puzzles in the future, but for now I would like even more to hang this project up as finished. I finished the solver well over a year ago in what was probably a single digit amount of hours. I have spent easily 5 times that on writing this series of blog posts, and it’s been weighing on me to wrap it up and publish it. I vastly underestimated the amount of time I would spend writing scripts to generate animations and just editing and rewriting large parts of the posts. Nonetheless I really enjoyed putting it all together and I’m eager to get working on the next project!<h1 id=additional-thoughts>Additional Thoughts</h1><p>While putting this post together, there were several things I wanted to write about but they generally didn’t add value to the plot. I decided to briefly cover them here for extra curious readers.<ol><li><p>I have thought a lot about how one might <em>generate</em> these puzzles. I did breifly take a stab at it with some decent results, but the puzzles a) didn’t support treasure rooms, and b) were of generally extreme difficulty, often <em>requiring</em> backtracking (which is a hallmark of poor puzzle design). If I decide to come back to this project, It would certainly be to tackle this problem and try to generate arbitrary-sized puzzles of prescribed difficulty.</p><li><p>My solver doesn’t use any logical deduction (for example “this row needs 4 walls and has 4 spaces, therefore they all must be walls”, or, “the space between a monster and a treasure room <em>must</em> be a wall”). I originally wanted to incorporate these into the solver, but with the speed I achieved they simply weren’t necessary. If I were to attempt solving larger puzzles (like 16x16), they perhaps would be mandatory to have acceptable solve times. There exists an <a href=https://dandd.therestinmotion.com/ rel=noopener target=_blank>online</a> puzzle generator which can produce larger puzzles, but occasionally it places invalid treasure rooms.</p><li><p>My solver is very finely tuned for 8x8 puzzles. It would not be impossible to adapt it to larger puzzles but would certainly require a couple hours of work. Of course, generating puzzles beyond 8x8 would require a solver that can prove they have a unique solution, so that work would need to be done if I take another stab at puzzle generation. I had the idea to use integer arrays for the bitboards for larger sizes, so instead of a <code>u64</code> with 8 bits per row in an 8x8 puzzle, I could use an array <code>[u16; 16]</code> to store 16 16-bit rows (or larger sizes with <code>[u32; 32]</code> or even <code>[u128; 128]</code> for the masochists). Doing bitwise operations between two bitmasks becomes a bit more involved but not difficult.</p><li><p>The speed I achieved is promising for the notion that much larger puzzles could be generated/solved. However, the solution space grows factorially due to the combinatorial nature of enumerating potential guesses. Incorporating some of the more trivial logical deduction techniques could improve this I imagine, but by how much remains to be seen.</p></ol><p>If you enjoyed this post. If you did, feel free to share it or drop a comment on <a href=https://bsky.app/profile/aaron404.bsky.social/post/3m3ui6dceb225 rel=noopener target=_blank>Bluesky</a> or <a href=https://www.reddit.com/r/rust/comments/1oe3gc7/making_games_play_themselves_with_rust_part_3/ rel=noopener target=_blank>Reddit</a><p class=tagsData></main><footer><hr><div class=footContainer><div class=footLeft><p>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme.<br></div></div></footer></div>