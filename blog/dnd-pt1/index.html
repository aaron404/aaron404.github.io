<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>Making games play themselves with Rust Part 1: Screen Interaction</title><meta content="Making games play themselves with Rust Part 1: Screen Interaction" name=title><meta content=Aaron name=author><meta content="An introduction to automated gaming!" name=description><meta content=website property=og:type><meta content=https://aaron404.github.io/blog/dnd-pt1/ property=og:url><meta content="My Blog" property=og:site_name><meta content="Making games play themselves with Rust Part 1: Screen Interaction" property=og:title><meta content="An introduction to automated gaming!" property=og:description><meta content=https://aaron404.github.io/blog/dnd-pt1/og_image.webp property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://aaron404.github.io/blog/dnd-pt1/ property=twitter:url><meta content="Making games play themselves with Rust Part 1: Screen Interaction" property=twitter:title><meta content="An introduction to automated gaming!" property=twitter:description><meta content=https://aaron404.github.io/blog/dnd-pt1/og_image.webp property=twitter:image><link href=https://aaron404.github.io/blog/dnd-pt1/ rel=canonical><link rel="shortcut icon" href=https://aaron404.github.io/favicon.ico type=image/x-icon><link href=https://aaron404.github.io/css/style.css rel=stylesheet><script defer src=https://aaron404.github.io/js/script.js></script><body><div class=wrapper><header><nav class=navBar><a href=/> home </a><a href=/journal> journal </a><a href=/blog> blog </a><div class=themeSwitch><button class="themeButton dark" onclick="setTheme('dark')" title="Dark mode"><svg class="icons icons__background"><use href=https://aaron404.github.io/icons.svg#darkMode></use></svg></button><button class="themeButton light" onclick="setTheme('light')" title="Light mode"><svg class="icons icons__background"><use href=https://aaron404.github.io/icons.svg#lightMode></use></svg></button></div></nav></header><main><time datetime=2024-06-24>Published on: <span class=metaData>2024-06-24</span></time><h1>Making games play themselves with Rust Part 1: Screen Interaction</h1><h2>Table of contents</h2><ul><li><a href=https://aaron404.github.io/blog/dnd-pt1/#introduction>Introduction</a><li><a href=https://aaron404.github.io/blog/dnd-pt1/#objectives>Objectives</a><li><a href=https://aaron404.github.io/blog/dnd-pt1/#the-rules>The Rules</a><li><a href=https://aaron404.github.io/blog/dnd-pt1/#capturing-the-screen>Capturing the Screen</a><li><a href=https://aaron404.github.io/blog/dnd-pt1/#error-handling>Error Handling</a><li><a href=https://aaron404.github.io/blog/dnd-pt1/#parsing-preparation>Parsing Preparation</a><li><a href=https://aaron404.github.io/blog/dnd-pt1/#2-fast-2-furious>2 Fast 2 Furious</a></ul><h1 id=introduction>Introduction</h1><p>Dungeons and Diagrams (henceforth referred to as DnD) is a minigame in Last Call BBS, the (unfortunately) final puzzle game released by Zachtronics before closing their studio to pursue other ventures. DnD is a logic game where the objective is to fill out an 8x8 grid with walls such that it forms a single contiguous open region along with a few other simple constraints. The game includes 63 curated puzzles of increasing difficulty for the player to solve, as well as an “infinite” mode that has 100 million randomly seeded puzzles of varying difficulty. You can try a online version of the game (unofficial) <a href=https://dandd.therestinmotion.com/ rel=noopener target=_blank>here</a>.<div class=textCenter><a class=img-link href=game.webp><img alt="Last Call BBS screenshot" src=game.webp></a><div class=caption>The Z5 Powerlance by Sawayama is a fictional retro PC. Once booted, the player can access various games, including Dungeons and Diagrams, shown here.</div><br></div><p>With some effort (the difficulty gets very high!) I manually solved the 63 curated puzzles, and approximately 170 of the seeded puzzles. As an avid Factorio enjoyer, I couldn’t help imagining how fun it would be to automate this game watch it play itself. I am writing this blog series to scratch that itch, as well as to provide something of a reference for anyone else who’s interested in game automation. There’s a lot to cover so I will split it into a few separate posts, and I’ll try to keep it interesting with lots of images. This post will cover the setup required to programmatically view pixels from the game and perform mouse and keyboard input.<p>I am writing my solver in Rust, running on Ubuntu 24.04. If you are on Windows or Mac, worry not, as I hope to make my implementation as platform-agnostic as possible. I am assuming some familiarity with Rust here but if you don’t know rust I hope the explanations along with the visuals will be interesting enough on their own.<h1 id=objectives>Objectives</h1><p>Before we get into the weeds, I’d like to set out my objectives for both this and subsequent posts. In this post, I would like to produce a program which can achieve the following:<ol><li>Find a window on the deskop given it’s title, in this case “Last Call BBS”.<li>Capture the framebuffer for that window, and peek into the pixel values.<li>Move the mouse to specific coordinates, and perform mouse input (left and right click).<li>Normalize these coordinates so everything is relative to the DnD sub-window.<li>(Bonus) Perform keyboard input. This isn’t needed for the solver, but it will help me with some testing and validation later.</ol><p>For future posts, I will cover (at least) the following:<ol><li>Parsing the game state<li>Solving the game with backtracking<li>Solving the game with FACTS and LOGIC<li>Generating my own puzzles (including much larger grid sizes)</ol><h1 id=the-rules>The Rules</h1><p>This game-within-a-game is reaching dangerous levels of niche, so it’d probably be best to kick things off with a brief introduction to the game’s rules and mechanics. The game provides the following tutorial (it is nicely animated in game, but I’ve snagged screenshots for your convenience):<div class=textCenter><a class=img-link href=tutorial.webp><img alt="Dungeons and Diagrams tutorial" src=tutorial.webp></a><div class=caption>The tutorial walks you through the logic required for a simple puzzle.</div><br></div><p>If the rules aren’t totally clear yet, I will elaborate on them in a future post where I implement the solver. For now just know that the player has to place the walls in the grid such that the above constraints are met. Each puzzle has a unique solution which can be derived through repeated application of the rules above. The game also encourages the player to use path markers (the red gems) to help keep track and assist in further deduction. Now, let’s get started!<h1 id=capturing-the-screen>Capturing the Screen</h1><p>Before we get into parsing the game state and simulating the player, we need a way to capture the pixels of the game and send user input back in response. There are many rust crates to accomplish these tasks, but I have chosen <a href=https://github.com/nashaofu/xcap rel=noopener target=_blank>xcap</a> for window queries and screen capture, and <a href=https://github.com/enigo-rs/enigo rel=noopener target=_blank>enigo</a> (this required installing libxdo as well) for user input. Both of these libraries claim to be cross-platform, so they should work on Windows and Mac as well.<p>Now, if you looked closely at the image in the <a href=https://aaron404.github.io/blog/dnd-pt1/#introduction>introduction</a>, you may have noticed that is has a screen distortion effect applied, which would make it difficult to reliably detect colors and positions of image features. It also has 2x pixel scaling, so there is a lot of redundant data in the image. Luckily both of these can be solved by modifying the graphics settings for the game.<div class=textCenter><a class=img-link href=settings.webp><img alt="Sawayama Z5 Powerlance Settings dialog" src=settings.webp></a><div class=caption>One of my favourite settings dialogs of all time.</div><br></div><p>Here I have changed to windowed mode with the smallest resolution, and disabled pixel stretching and the screen effect.<div class=textCenter><a class=img-link href=game_small.webp><img alt="Undistorted screen" src=game_small.webp></a><div class=caption>Screen minus the distortion effect.</div><br></div><p>The result is a game window with 1:1 pixel sizes and no distortion. The downside is that it makes it a tiny window on my monitor, requiring me to sit pretty close to the screen if I am playing it manually. Luckily, if all goes to plan, the game will soon be playing itself!<p>Now we can begin with a simple app to find a window by name, and move the mouse to the center of it. For fun let’s also use a keystroke to open and close the tutorial (F1), send a click, and take a screenshot.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#9a9082>use </span><span>std::{thread, time::Duration};
</span><span>
</span><span style=color:#9a9082>use </span><span>enigo::{Button, Coordinate, Direction, Enigo, Key, Keyboard, Mouse, Settings};
</span><span style=color:#9a9082>use </span><span>xcap::Window;
</span><span>
</span><span style=color:#95cc5e>const </span><span style=color:#db784d>GAME_TITLE</span><span>: </span><span style=color:#db784d>&</span><span style=color:#95cc5e>str </span><span style=color:#db784d>= </span><span style=color:#eaae2e>"Last Call BBS"</span><span>;
</span><span>
</span><span style=color:#95cc5e>fn </span><span style=color:#60a365>main</span><span>() {
</span><span>    </span><span style=color:#7a7267>// Create an iterator over all the open windows
</span><span>    </span><span style=color:#95cc5e>let</span><span> windows </span><span style=color:#db784d>= </span><span>Window::all().</span><span style=color:#95cc5e>unwrap</span><span>();
</span><span>
</span><span>    </span><span style=color:#7a7267>// Search for our specific window 
</span><span>    </span><span style=color:#95cc5e>let</span><span> window </span><span style=color:#db784d>=</span><span> windows
</span><span>        .</span><span style=color:#95cc5e>iter</span><span>()
</span><span>        .</span><span style=color:#95cc5e>find</span><span>(|</span><span style=font-style:italic;color:#f8bb39>win</span><span>| win.</span><span style=color:#95cc5e>title</span><span>() </span><span style=color:#db784d>== GAME_TITLE</span><span>)
</span><span>        .</span><span style=color:#95cc5e>unwrap</span><span>();
</span><span>
</span><span>    </span><span style=color:#7a7267>// Initialize enigo input simulator
</span><span>    </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> enigo </span><span style=color:#db784d>= </span><span>Enigo::new(</span><span style=color:#db784d>&</span><span>Settings::default()).</span><span style=color:#95cc5e>unwrap</span><span>();
</span><span>
</span><span>    </span><span style=color:#7a7267>// Move the mouse
</span><span>    enigo
</span><span>        .</span><span style=color:#95cc5e>move_mouse</span><span>(
</span><span>            window.</span><span style=color:#95cc5e>x</span><span>() </span><span style=color:#db784d>+</span><span> window.</span><span style=color:#95cc5e>width</span><span>() </span><span style=color:#db784d>as </span><span style=color:#95cc5e>i32 </span><span style=color:#db784d>/ </span><span style=color:#eaae2e>2</span><span>,
</span><span>            window.</span><span style=color:#95cc5e>y</span><span>() </span><span style=color:#db784d>+</span><span> window.</span><span style=color:#95cc5e>height</span><span>() </span><span style=color:#db784d>as </span><span style=color:#95cc5e>i32 </span><span style=color:#db784d>/ </span><span style=color:#eaae2e>2</span><span>,
</span><span>            Coordinate::Abs,
</span><span>        )
</span><span>        .</span><span style=color:#95cc5e>unwrap</span><span>();
</span><span>
</span><span>    </span><span style=color:#7a7267>// Click
</span><span>    enigo.</span><span style=color:#95cc5e>button</span><span>(Button::Left, Direction::Click).</span><span style=color:#95cc5e>unwrap</span><span>();
</span><span>
</span><span>    </span><span style=color:#7a7267>// Open and close the tutorial
</span><span>    enigo.</span><span style=color:#95cc5e>key</span><span>(Key::</span><span style=color:#db784d>F1</span><span>, Direction::Click);
</span><span>    thread::sleep(Duration::from_millis(</span><span style=color:#eaae2e>100</span><span>));
</span><span>    enigo.</span><span style=color:#95cc5e>key</span><span>(Key::</span><span style=color:#db784d>F1</span><span>, Direction::Click);
</span><span>    thread::sleep(Duration::from_millis(</span><span style=color:#eaae2e>100</span><span>));
</span><span>
</span><span>    </span><span style=color:#7a7267>// Take a screenshot
</span><span>    </span><span style=color:#95cc5e>let</span><span> img </span><span style=color:#db784d>=</span><span> window.</span><span style=color:#95cc5e>capture_image</span><span>().</span><span style=color:#95cc5e>unwrap</span><span>();
</span><span>    img.</span><span style=color:#95cc5e>save</span><span>(</span><span style=color:#eaae2e>"game.png"</span><span>).</span><span style=color:#95cc5e>unwrap</span><span>();
</span><span>}
</span><span>
</span></code></pre><p>This results in the image below - we placed a wall! I had to add <code>thread::sleep</code> in there otherwise the screenshot would happen faster than the game could process the input. The tutorial window also opens and closes as expected, but I didn’t capture it in the image.<div class=textCenter><a class=img-link href=clicked.webp><img alt="After placing a wall." src=clicked.webp></a><div class=caption>Screen after placing a single wall tile.</div><br></div><p>This performs as expected, with a small caveat that it seems to require the mouse to already be above the Last Call BBS window or else the movement and click don’t register. I believe this is likely a bug with Enigo, but for now I’ll live with the limitation as it’s pretty minor.<h1 id=error-handling>Error Handling</h1><p>Let’s remove those unsightly <code>unwrap</code> calls, and put some proper error handling in place. Almost every action I perform here is falliable. I’m going to wrap them into a custom <code>InitError</code>, describing things that could go wrong during program initialization. At the same time, I’m going to wrap my existing functionality into a new struct <code>DungeonCrawler</code> that will store some persistent data for later use. Lastly, it will be important to know where the Dungeons and Diagrams subwindow is located with respect to the main game window, so I’ll add a function to locate that offset.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span>#[</span><span style=color:#207241>derive</span><span>(Debug)]
</span><span style=color:#95cc5e>enum </span><span>InitError {
</span><span>    BBSNotFound,                            </span><span style=color:#7a7267>// Game is not running
</span><span>    SearchError(SearchError),               </span><span style=color:#7a7267>// DnD sub-window location error
</span><span>    XCapError(xcap::XCapError),             </span><span style=color:#7a7267>// xcap error wrapper
</span><span>    EnigoError(enigo::NewConError),         </span><span style=color:#7a7267>// enigo error wrapper
</span><span>    ImageError(xcap::image::ImageError),    </span><span style=color:#7a7267>// image capture error wrapper
</span><span>}
</span><span>
</span><span>#[</span><span style=color:#207241>derive</span><span>(Debug)]
</span><span style=color:#95cc5e>enum </span><span>SearchError {
</span><span>    NotFound,                 </span><span style=color:#7a7267>// DnD sub-window couldn't be located
</span><span>    MultipleResults(</span><span style=color:#95cc5e>usize</span><span>),   </span><span style=color:#7a7267>// Multiple matches were found for the pattern
</span><span>    OutOfBounds,              </span><span style=color:#7a7267>// Window found, but it is partially out of bounds
</span><span>}
</span></code></pre><p>This may not be the perfect way to do error handling in Rust. I am no expert, but I have found this to be a pretty concise and ergonomic way of working with them (in tandem with the <code>?</code> operator and <code>map_err</code>). All errors will eventually bubble up to <code>main()</code> where the program will print the error and exit gracefully. Now on to the <code>DungeonCrawler</code> implementation.<h1 id=parsing-preparation>Parsing Preparation</h1><p>This is pretty similar to the test application we saw earlier. Notable additions are the call to <code>find_dnd_offset</code> which looks for the DnD window, and a call to <code>img.view()</code> to save a cropped screenshot containing only the DnD window. Saving the images to disk is not really necessary, but it may be useful for debugging in the future so it doesn’t hurt. At the end of initialization, I also <code>click(0, 0)</code> which forces the window to capture the mouse, working around the caveat I mentioned earlier.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#95cc5e>struct </span><span>DungeonCrawler {
</span><span>    </span><span style=color:#f8bb39>enigo</span><span>: Enigo,
</span><span>    </span><span style=color:#f8bb39>window</span><span>: Window,
</span><span>    </span><span style=color:#f8bb39>offset</span><span>: (</span><span style=color:#95cc5e>u32</span><span>, </span><span style=color:#95cc5e>u32</span><span>),
</span><span>}
</span><span>
</span><span style=color:#95cc5e>impl </span><span>DungeonCrawler {
</span><span>    </span><span style=color:#95cc5e>fn </span><span style=color:#60a365>new</span><span>() -> </span><span style=font-style:italic;color:#db784d>Result</span><span><</span><span style=color:#95cc5e>Self</span><span>, InitError> {
</span><span>        </span><span style=color:#7a7267>// Find 'Last Call BBS' window
</span><span>        </span><span style=color:#95cc5e>let</span><span> windows </span><span style=color:#db784d>= </span><span>Window::all().</span><span style=color:#95cc5e>unwrap</span><span>();
</span><span>        </span><span style=color:#95cc5e>let</span><span> window </span><span style=color:#db784d>=</span><span> windows
</span><span>            .</span><span style=color:#95cc5e>iter</span><span>()
</span><span>            .</span><span style=color:#95cc5e>find</span><span>(|</span><span style=font-style:italic;color:#f8bb39>win</span><span>| win.</span><span style=color:#95cc5e>title</span><span>() </span><span style=color:#db784d>== GAME_TITLE</span><span>)
</span><span>            .</span><span style=color:#95cc5e>ok_or</span><span>(InitError::BBSNotFound)</span><span style=color:#db784d>?
</span><span>            .</span><span style=color:#95cc5e>clone</span><span>();
</span><span>
</span><span>        </span><span style=color:#7a7267>// Capture the screen
</span><span>        </span><span style=color:#95cc5e>let</span><span> img </span><span style=color:#db784d>=</span><span> window
</span><span>            .</span><span style=color:#95cc5e>capture_image</span><span>()
</span><span>            .</span><span style=color:#95cc5e>map_err</span><span>(|</span><span style=font-style:italic;color:#f8bb39>e</span><span>| InitError::XCapError(e))</span><span style=color:#db784d>?</span><span>;
</span><span>        img.</span><span style=color:#95cc5e>save</span><span>(</span><span style=color:#eaae2e>"game.png"</span><span>).</span><span style=color:#95cc5e>map_err</span><span>(|</span><span style=font-style:italic;color:#f8bb39>e</span><span>| InitError::ImageError(e))</span><span style=color:#db784d>?</span><span>;
</span><span>
</span><span>        </span><span style=color:#7a7267>// Locate DnD subwindow
</span><span>        </span><span style=color:#95cc5e>let</span><span> dnd_offset </span><span style=color:#db784d>= </span><span style=color:#95cc5e>find_dnd_offset</span><span>(</span><span style=color:#db784d>&</span><span>img).</span><span style=color:#95cc5e>map_err</span><span>(|</span><span style=font-style:italic;color:#f8bb39>e</span><span>| InitError::SearchError(e))</span><span style=color:#db784d>?</span><span>;
</span><span>        img.</span><span style=color:#95cc5e>view</span><span>(dnd_offset.</span><span style=color:#eaae2e>0</span><span>, dnd_offset.</span><span style=color:#eaae2e>1</span><span>, </span><span style=color:#db784d>GAME_CROP</span><span>.</span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#db784d>GAME_CROP</span><span>.</span><span style=color:#eaae2e>1</span><span>)
</span><span>            .</span><span style=color:#95cc5e>to_image</span><span>()
</span><span>            .</span><span style=color:#95cc5e>save</span><span>(</span><span style=color:#eaae2e>"dnd.png"</span><span>)
</span><span>            .</span><span style=color:#95cc5e>map_err</span><span>(|</span><span style=font-style:italic;color:#f8bb39>e</span><span>| InitError::ImageError(e))</span><span style=color:#db784d>?</span><span>;
</span><span>
</span><span>        </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> dc </span><span style=color:#db784d>= </span><span style=color:#95cc5e>Self </span><span>{
</span><span>            enigo: Enigo::new(</span><span style=color:#db784d>&</span><span>Settings::default()).</span><span style=color:#95cc5e>map_err</span><span>(|</span><span style=font-style:italic;color:#f8bb39>e</span><span>| InitError::EnigoError(e))</span><span style=color:#db784d>?</span><span>,
</span><span>            offset: (
</span><span>                window.</span><span style=color:#95cc5e>x</span><span>() </span><span style=color:#db784d>as </span><span style=color:#95cc5e>u32 </span><span style=color:#db784d>+</span><span> dnd_offset.</span><span style=color:#eaae2e>0</span><span>,
</span><span>                window.</span><span style=color:#95cc5e>y</span><span>() </span><span style=color:#db784d>as </span><span style=color:#95cc5e>u32 </span><span style=color:#db784d>+</span><span> dnd_offset.</span><span style=color:#eaae2e>1</span><span>,
</span><span>            ),
</span><span>            window,
</span><span>        };
</span><span>
</span><span>        </span><span style=color:#7a7267>// Force a click to capture the mouse in the application
</span><span>        dc.</span><span style=color:#95cc5e>click</span><span>(</span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#eaae2e>0</span><span>)
</span><span>            .</span><span style=color:#95cc5e>map_err</span><span>(|</span><span style=font-style:italic;color:#f8bb39>e</span><span>| InitError::MouseCaptureError(e))</span><span style=color:#db784d>?</span><span>;
</span><span>
</span><span>        </span><span style=font-style:italic;color:#db784d>Ok</span><span>(dc)
</span><span>    }
</span><span>}
</span></code></pre><p>To find the location of the DnD window, I spent a bit of time looking for a small pattern of pixels that could be considered unique given the entire rest of the screen. I wanted it to be fast so I kept it to a short pattern of 3 pixels (12 bytes). The pattern is located in the top-left corner of the <code>x</code> button to close the DnD window.<div class=textCenter><a class=img-link href=pattern.webp><img alt="Closeup of the window pattern." src=pattern.webp></a><div class=caption>Enhance!</div><br></div><p>In code, I have to also add alpha channel bytes, hence the extra 255’s. The exact pattern can be seen in the snippet below:<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#95cc5e>fn </span><span style=color:#60a365>find_dnd_offset</span><span>(</span><span style=font-style:italic;color:#f8bb39>image</span><span>: </span><span style=color:#db784d>&</span><span>Image) -> </span><span style=font-style:italic;color:#db784d>Result</span><span><(</span><span style=color:#95cc5e>u32</span><span>, </span><span style=color:#95cc5e>u32</span><span>), SearchError> {
</span><span>    </span><span style=color:#7a7267>// Pattern of image bytes to uniquely locate the DnD subwindow. The chosen pattern
</span><span>    </span><span style=color:#7a7267>// exists at 299,0 relative to the top left corner of the subwindow.
</span><span>    </span><span style=color:#95cc5e>const </span><span style=color:#db784d>PATTERN_LEN</span><span>: </span><span style=color:#95cc5e>usize </span><span style=color:#db784d>= </span><span style=color:#eaae2e>12</span><span>;
</span><span>    </span><span style=color:#95cc5e>const </span><span style=color:#db784d>PATTERN</span><span>: [</span><span style=color:#95cc5e>u8</span><span>; </span><span style=color:#db784d>PATTERN_LEN</span><span>] </span><span style=color:#db784d>= </span><span>[</span><span style=color:#eaae2e>69</span><span>, </span><span style=color:#eaae2e>52</span><span>, </span><span style=color:#eaae2e>56</span><span>, </span><span style=color:#eaae2e>255</span><span>, </span><span style=color:#eaae2e>237</span><span>, </span><span style=color:#eaae2e>169</span><span>, </span><span style=color:#eaae2e>135</span><span>, </span><span style=color:#eaae2e>255</span><span>, </span><span style=color:#eaae2e>181</span><span>, </span><span style=color:#eaae2e>147</span><span>, </span><span style=color:#eaae2e>131</span><span>, </span><span style=color:#eaae2e>255</span><span>];
</span><span>    </span><span style=color:#95cc5e>const </span><span style=color:#db784d>PATTERN_OFFSET</span><span>: (</span><span style=color:#95cc5e>u32</span><span>, </span><span style=color:#95cc5e>u32</span><span>) </span><span style=color:#db784d>= </span><span>(</span><span style=color:#eaae2e>299</span><span>, </span><span style=color:#eaae2e>0</span><span>);
</span><span>
</span><span>    </span><span style=color:#7a7267>// Iterate over sliding window of 12 bytes, considering only every 4th window (pixel alignment)
</span><span>    </span><span style=color:#95cc5e>let</span><span> matches </span><span style=color:#db784d>=</span><span> image
</span><span>        .array_windows::&LTPATTERN_LEN>()
</span><span>        .</span><span style=color:#95cc5e>step_by</span><span>(</span><span style=color:#eaae2e>4</span><span>)
</span><span>        .</span><span style=color:#95cc5e>enumerate</span><span>()
</span><span>        .</span><span style=color:#95cc5e>filter_map</span><span>(|(</span><span style=font-style:italic;color:#f8bb39>i</span><span>, &</span><span style=font-style:italic;color:#f8bb39>chunk</span><span>)| {
</span><span>            </span><span style=color:#db784d>if</span><span> chunk </span><span style=color:#db784d>== PATTERN </span><span>{
</span><span>                </span><span style=color:#7a7267>// Given the window index, calculate x and y offsets. Unsigned
</span><span>                </span><span style=color:#7a7267>// wrapping subtraction here simplifies the bounds check later
</span><span>                </span><span style=font-style:italic;color:#db784d>Some</span><span>((
</span><span>                    (i </span><span style=color:#db784d>as </span><span style=color:#95cc5e>u32 </span><span style=color:#db784d>%</span><span> image.</span><span style=color:#95cc5e>width</span><span>()).</span><span style=color:#95cc5e>wrapping_sub</span><span>(</span><span style=color:#db784d>PATTERN_OFFSET</span><span>.</span><span style=color:#eaae2e>0</span><span>),
</span><span>                    (i </span><span style=color:#db784d>as </span><span style=color:#95cc5e>u32 </span><span style=color:#db784d>/</span><span> image.</span><span style=color:#95cc5e>width</span><span>()).</span><span style=color:#95cc5e>wrapping_sub</span><span>(</span><span style=color:#db784d>PATTERN_OFFSET</span><span>.</span><span style=color:#eaae2e>1</span><span>),
</span><span>                ))
</span><span>            } </span><span style=color:#db784d>else </span><span>{
</span><span>                </span><span style=font-style:italic;color:#db784d>None
</span><span>            }
</span><span>        })
</span><span>        .collect::<</span><span style=font-style:italic;color:#db784d>Vec</span><span><(</span><span style=color:#95cc5e>u32</span><span>, </span><span style=color:#95cc5e>u32</span><span>)>>();
</span><span>
</span><span>    </span><span style=color:#9a9082>use </span><span>SearchError::</span><span style=color:#db784d>*</span><span>;
</span><span>    </span><span style=color:#db784d>match</span><span> matches.</span><span style=color:#95cc5e>len</span><span>() {
</span><span>        </span><span style=color:#eaae2e>0 </span><span style=color:#db784d>=> </span><span style=font-style:italic;color:#db784d>Err</span><span>(NotFound),
</span><span>        </span><span style=color:#eaae2e>1 </span><span style=color:#db784d>=> </span><span>{
</span><span>            </span><span style=color:#95cc5e>let </span><span>(x, y) </span><span style=color:#db784d>=</span><span> matches[</span><span style=color:#eaae2e>0</span><span>];
</span><span>            </span><span style=color:#db784d>if</span><span> x </span><span style=color:#db784d>> </span><span style=color:#eaae2e>625 </span><span style=color:#db784d>||</span><span> y </span><span style=color:#db784d>> </span><span style=color:#eaae2e>80 </span><span>{
</span><span>                </span><span style=font-style:italic;color:#db784d>Err</span><span>(OutOfBounds)
</span><span>            } </span><span style=color:#db784d>else </span><span>{
</span><span>                </span><span style=font-style:italic;color:#db784d>Ok</span><span>(matches[</span><span style=color:#eaae2e>0</span><span>])
</span><span>            }
</span><span>        }
</span><span>        n </span><span style=color:#db784d>=> </span><span style=font-style:italic;color:#db784d>Err</span><span>(MultipleResults(n)),
</span><span>    }
</span><span>}
</span></code></pre><p>This code works by iterating over the image as a sequence of bytes. <code>array_windows::&LTPATTERN_LEN></code> gives me an iterator that looks at a sliding window of 12 bytes, and <code>step_by(4)</code> lets me only consider every 4th window, giving me alignment with pixel boundaries. I enumerate these windows so I can later compute the X/Y coordinates and filter the windows based on whether or not any given sequence of 12 bytes matches my pattern. The result is mapped into a simple list of (x, y) tuples.<p>As I was experimenting with patterns, it was not uncommon to find multiple matches, so I explicitly handle that case and consider it to be an error. Additionally, it is possible to locate the window offset but calculate that it must not be fully visible on screen, so I also handle <code>OutOfBounds</code> as another failure case.<p>Finally, I can rewrite <code>main</code> to create an instance of <code>DungeonCrawler</code> which should compute the global offset from the top left corner of my monitor to the top left corner of the DnD window<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#95cc5e>fn </span><span style=color:#60a365>main</span><span>() {
</span><span>    </span><span style=color:#95cc5e>let</span><span> dc </span><span style=color:#db784d>= match </span><span>DungeonCrawler::new() {
</span><span>        </span><span style=font-style:italic;color:#db784d>Ok</span><span>(d) </span><span style=color:#db784d>=></span><span> d,
</span><span>        </span><span style=font-style:italic;color:#db784d>Err</span><span>(e) </span><span style=color:#db784d>=> </span><span>{
</span><span>            eprintln!(</span><span style=color:#eaae2e>"Error: </span><span style=color:#db784d>{:#?}</span><span style=color:#eaae2e>"</span><span>, e);
</span><span>            std::process::exit(</span><span style=color:#eaae2e>1</span><span>)
</span><span>        }
</span><span>    };
</span><span>
</span><span>    println!(</span><span style=color:#eaae2e>"offset: </span><span style=color:#db784d>{:?}</span><span style=color:#eaae2e>"</span><span>, dc.offset);
</span><span>}
</span></code></pre><p>Sure enough, running this produces the following output:<pre style=background:#191919;color:#e8d4c0><code><span>offset: (284, 126)
</span></code></pre><p>Which we can manually verify in the following image. I’ve painted a single red pixel in the top left corner of the DnD window with some helpful arrows because a single pixel may be hard to spot. It actually sits a bit outside of the actual window because the top left corner is beveled. I used GIMP to check the pixel coordinate, but feel free to count it yourself!<div class=textCenter><a class=img-link href=offset.webp><img alt="Location of window 'anchor'" src=offset.webp></a><div class=caption>The window 'anchor' point.</div><br></div><p>From this point on, I can use this offset to normalize my coordinates to the DnD window. I don’t need to care about where the game client is located on my monitor or where the DnD window is located within the game client.<h1 id=2-fast-2-furious>2 Fast 2 Furious</h1><p>With the DnD window offset calculated, I’ll add a helper function <code>click()</code> that will add the offset to any coordinates I pass in so I can more easily plan out where clicks are sent. I’ve defined a constant <code>CLICK_DELAY</code> which I can use to allow a bit of time to pass between each input. Sending too much input to a game often results in events being dropped or the game stuttering as it tries to process everything so quickly. To avoid dropping events, I’ll test a few values for this delay and try to find something that is as fast as possible without dropping any events. Here’s <code>click()</code>:<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#7a7267>// time (ms) to wait after a click before sending the next one
</span><span style=color:#95cc5e>const </span><span style=color:#db784d>CLICK_DELAY</span><span>: </span><span style=color:#95cc5e>u64 </span><span style=color:#db784d>= </span><span style=color:#eaae2e>15</span><span>;
</span><span>
</span><span style=color:#95cc5e>impl </span><span>DungeonCrawler {
</span><span>    </span><span style=color:#7a7267>// constructor hidden for brevity
</span><span>    </span><span style=color:#95cc5e>fn </span><span style=color:#60a365>new</span><span>() -> </span><span style=font-style:italic;color:#db784d>Result</span><span><</span><span style=color:#95cc5e>Self</span><span>, InitError> { </span><span style=color:#db784d>... </span><span>}
</span><span>    
</span><span>    </span><span style=color:#95cc5e>fn </span><span style=color:#60a365>click</span><span>(</span><span style=color:#db784d>&mut </span><span style=font-style:italic;color:#f8bb39>self</span><span>, </span><span style=font-style:italic;color:#f8bb39>x</span><span>: </span><span style=color:#95cc5e>u32</span><span>, </span><span style=font-style:italic;color:#f8bb39>y</span><span>: </span><span style=color:#95cc5e>u32</span><span>) -> InputResult<()> {
</span><span>        </span><span style=color:#95cc5e>let</span><span> cx </span><span style=color:#db784d>= </span><span>(x </span><span style=color:#db784d>+ </span><span style=color:#207241>self</span><span>.offset.</span><span style=color:#eaae2e>0</span><span>) </span><span style=color:#db784d>as </span><span style=color:#95cc5e>i32</span><span>;
</span><span>        </span><span style=color:#95cc5e>let</span><span> cy </span><span style=color:#db784d>= </span><span>(y </span><span style=color:#db784d>+ </span><span style=color:#207241>self</span><span>.offset.</span><span style=color:#eaae2e>1</span><span>) </span><span style=color:#db784d>as </span><span style=color:#95cc5e>i32</span><span>;
</span><span>        </span><span style=color:#207241>self</span><span>.enigo.</span><span style=color:#95cc5e>move_mouse</span><span>(cx, cy, Coordinate::Abs)</span><span style=color:#db784d>?</span><span>;
</span><span>        thread::sleep(Duration::from_millis(</span><span style=color:#db784d>CLICK_DELAY / </span><span style=color:#eaae2e>2</span><span>));
</span><span>        </span><span style=color:#207241>self</span><span>.enigo.</span><span style=color:#95cc5e>button</span><span>(Button::Left, Direction::Click)</span><span style=color:#db784d>?</span><span>;
</span><span>        thread::sleep(Duration::from_millis(</span><span style=color:#db784d>CLICK_DELAY / </span><span style=color:#eaae2e>2</span><span>));
</span><span>        </span><span style=font-style:italic;color:#db784d>Ok</span><span>(())
</span><span>    }
</span><span>}
</span></code></pre><p>You may notice I am using <code>CLICK_DELAY</code> to sleep twice per click. It seems like sending a click instantaneously after moving the mouse could be prone to failure, so I’ll pre-emptively avoid any funny business there. Somewhat arbitrarily, I’ve chosen to use a delay of 15ms, which with 64 squares comes out pretty close to exactly 1 second for a single pass.<p>To put this function through its paces, I’ll write a simple loop that tries to place a wall in every cell of the board, followed by a second pass to clear them. I’ll repeat this entire process a couple times and manually watch to see if any clicks are missed.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#7a7267>// added to main()
</span><span>
</span><span>    </span><span style=color:#7a7267>// repeat 8 times
</span><span>    </span><span style=color:#db784d>for _ in </span><span style=color:#eaae2e>0</span><span style=color:#db784d>..</span><span style=color:#eaae2e>8 </span><span>{
</span><span>        </span><span style=color:#db784d>for</span><span> i </span><span style=color:#db784d>in </span><span style=color:#eaae2e>0</span><span style=color:#db784d>..</span><span style=color:#eaae2e>8 </span><span>{
</span><span>            </span><span style=color:#db784d>for</span><span> j </span><span style=color:#db784d>in </span><span style=color:#eaae2e>0</span><span style=color:#db784d>..</span><span style=color:#eaae2e>8 </span><span>{
</span><span>                </span><span style=color:#95cc5e>let</span><span> cx </span><span style=color:#db784d>=</span><span> i </span><span style=color:#db784d>* </span><span style=color:#eaae2e>33 </span><span style=color:#db784d>+ </span><span style=color:#eaae2e>66</span><span>;
</span><span>                </span><span style=color:#95cc5e>let</span><span> cy </span><span style=color:#db784d>=</span><span> j </span><span style=color:#db784d>* </span><span style=color:#eaae2e>33 </span><span style=color:#db784d>+ </span><span style=color:#eaae2e>191</span><span>;
</span><span>                dc.</span><span style=color:#95cc5e>click</span><span>(cx, cy).</span><span style=color:#95cc5e>unwrap</span><span>();
</span><span>            }
</span><span>        }
</span><span>    }
</span></code></pre><p>And now for the results. Drumroll please!</p><center> <video alt="Video of speed clicking" onclick="this.paused ? this.play() : this.pause();" autoplay loop src=clicktest.webm></video> <div class=caption>I guess you didn't drumroll hard enough.</div> </center><p>Unfortunately, we can see after each pass of clicks there are several walls/holes that are missed. Luckily, backing it off to 20ms per click makes it much more reliable. I still see a click dropped occasionally, even with higher delays like 50-100ms, but I will ignore that for now until I start solving puzzles at scale. In a real puzzle solution, usually less than half the cells will be walls and need clicking, so I should still be able to input solutions in under a second.<p>This brings us to the end of the post. I’ll continue next time with some text parsing and sprite detection. In the meantime, please enjoy this video of the autoclicker working successfully iterating over randomly ordered cells.</p><center> <video alt="Speedclicking, properly" onclick="this.paused ? this.play() : this.pause();" autoplay loop src=clicktest2.webm></video> <div class=caption>Speedclicking, properly.</div> </center><p class=tagsData></main><footer><hr><div class=footContainer><div class=footLeft><p>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme.<br></div></div></footer></div>