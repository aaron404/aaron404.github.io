<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>Making games play themselves with Rust Part 2: Parsing the Game State</title><meta content="Making games play themselves with Rust Part 2: Parsing the Game State" name=title><meta content=Aaron name=author><meta content="Efficiently detecting the state of a game!" name=description><meta content=website property=og:type><meta content=https://aaron404.github.io/blog/dnd-pt2/ property=og:url><meta content="My Blog" property=og:site_name><meta content="Making games play themselves with Rust Part 2: Parsing the Game State" property=og:title><meta content="Efficiently detecting the state of a game!" property=og:description><meta content=https://aaron404.github.io/blog/dnd-pt1/og_image.webp property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://aaron404.github.io/blog/dnd-pt2/ property=twitter:url><meta content="Making games play themselves with Rust Part 2: Parsing the Game State" property=twitter:title><meta content="Efficiently detecting the state of a game!" property=twitter:description><meta content=https://aaron404.github.io/blog/dnd-pt1/og_image.webp property=twitter:image><link href=https://aaron404.github.io/blog/dnd-pt2/ rel=canonical><link rel="shortcut icon" href=https://aaron404.github.io/favicon.ico type=image/x-icon><link href=https://aaron404.github.io/css/style.css rel=stylesheet><script defer src=https://aaron404.github.io/js/script.js></script><body><div class=wrapper><header><nav class=navBar><a href=/> home </a><a href=/journal> journal </a><a href=/blog> blog </a><div class=themeSwitch><button class="themeButton dark" onclick="setTheme('dark')" title="Dark mode"><svg class="icons icons__background"><use href=https://aaron404.github.io/icons.svg#darkMode></use></svg></button><button class="themeButton light" onclick="setTheme('light')" title="Light mode"><svg class="icons icons__background"><use href=https://aaron404.github.io/icons.svg#lightMode></use></svg></button></div></nav></header><main><time datetime=2024-07-26>Published on: <span class=metaData>2024-07-26</span></time><h1>Making games play themselves with Rust Part 2: Parsing the Game State</h1><h2>Table of contents</h2><ul><li><a href=https://aaron404.github.io/blog/dnd-pt2/#introduction>Introduction</a><li><a href=https://aaron404.github.io/blog/dnd-pt2/#quick-note-about-error-handling>Quick note about error handling</a><li><a href=https://aaron404.github.io/blog/dnd-pt2/#the-game-state>The Game State</a><li><a href=https://aaron404.github.io/blog/dnd-pt2/#structure-from-pixels>Structure from Pixels</a> <ul><li><a href=https://aaron404.github.io/blog/dnd-pt2/#discriminants>Discriminants</a> <ul></ul><li><a href=https://aaron404.github.io/blog/dnd-pt2/#parsing-the-tiles>Parsing the Tiles</a> <ul></ul><li><a href=https://aaron404.github.io/blog/dnd-pt2/#reading-numbers>Reading Numbers</a> <ul></ul><li><a href=https://aaron404.github.io/blog/dnd-pt2/#harvesting-the-seed>Harvesting the Seed</a> <ul></ul></ul><li><a href=https://aaron404.github.io/blog/dnd-pt2/#bringing-it-all-together>Bringing it All Together</a><li><a href=https://aaron404.github.io/blog/dnd-pt2/#serialization-deserialization>Serialization/Deserialization</a><li><a href=https://aaron404.github.io/blog/dnd-pt2/#bonus-testing>(Bonus) Testing</a><li><a href=https://aaron404.github.io/blog/dnd-pt2/#conclusion>Conclusion</a></ul><h1 id=introduction>Introduction</h1><p>Last time I laid the foundation for game state parsing, namely reading pixels from the screen and normalizing the coordinate system so we don’t have to worry about the rest of the screen outside the Dungeons and Diagrams window. Today I’d like to go from a screenshot with half a million pixels to a Rust object that I can write a solver around. With that said, my objectives for today are:<ol><li>Detect tile contents (Empty, Treasure, or Monster)<li>Parse the numbers on the top and left side of the board<li>Parse the room seed<li>Read and write the board state to/from a file<li>(Bonus) Testing</ol><h1 id=quick-note-about-error-handling>Quick note about error handling</h1><p>In the previous post I made some custom error types to handle all the failure modes of my program. I ended up rewriting these to use <code>anyhow</code> which reduces boilerplate for cases where you don’t need to recover from the errors. If I hit an error at runtime it is enough to print a message with some information about what went wrong and exit.<h1 id=the-game-state>The Game State</h1><p>A puzzle in Dungeons and Diagrams has a pretty simple state representation. The puzzle requires only 16 numbers between 0 and 7 (inclusive) and 64 tiles which can each be in one of 5 states. For the randomly generated puzzles there is additionally a seed between 0 and 99999999, but the original 63 curated puzzles do not have one.<div class=textCenter><a class=img-link href=states.webp><img alt="Examples of each state" src=states.webp></a><div class=caption>From left to right: Path, Treasure, Wall, Empty, Monster</div><br></div><p>I chose to represent the tiles as an <code>enum</code> with 5 variants. The numbers on each side of the board which represent the number of walls required for each row and column are represented with byte arrays. Lastly the seed, which may or not be present depending on whether this is a curated puzzle or not, can be wrapped in an <code>Option</code>. It can range from 0 to 99,999,999 so it fits nicely in a <code>u32</code>.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#95cc5e>enum </span><span>Tile {
</span><span>    Empty,
</span><span>    Wall,
</span><span>    Path,
</span><span>    Treasure,
</span><span>    Monster,
</span><span>}
</span><span>
</span><span style=color:#95cc5e>struct </span><span>Puzzle {
</span><span>    </span><span style=color:#f8bb39>tiles</span><span>: [[Tile; 8]; 8],
</span><span>    </span><span style=color:#f8bb39>top_nums</span><span>: [</span><span style=color:#95cc5e>u8</span><span>; 8],
</span><span>    </span><span style=color:#f8bb39>left_nums</span><span>: [</span><span style=color:#95cc5e>u8</span><span>; 8],
</span><span>    </span><span style=color:#db784d>pub </span><span style=color:#f8bb39>seed</span><span>: </span><span style=font-style:italic;color:#db784d>Option</span><span><</span><span style=color:#95cc5e>u32</span><span>>,
</span><span>}
</span></code></pre><p>For now I used <code>u8</code>s to represent the numbers because given the rules, I knew they can never be larger than 8. In the future I’d like to try generating extremely large puzzles of my own, so I may come back and revise this struct to use a larger datatype for these variables.<h1 id=structure-from-pixels>Structure from Pixels</h1><p>I had to teach my compute how to see - it needed some way to take a collection of ~500 thousand pixels and intelligently filling out the <code>Puzzle</code> struct. It was tempting to reach into the big bag of AI tricks that have become so prevalent in recent years, but I wanted to have complete understanding of the model that is being used to analyze my screenshots. The parsing had to be accurate without relying on flimsy statistical assurances.<p>Since there are only a small number of digits and a handful of monsters to identify, I figured I could use the game’s retro style to my advantage. The low resolution and limited color palette vastly cut down the amount of patterns I had to consider. Furthermore, I assumed the player hasn’t made any moves to solve the puzzle yet so there will be no <code>Wall</code> or <code>Path</code> tiles placed, which reduced the possibilities to the 3 remaining options (<code>Monster</code>, <code>Treasure</code>, and <code>Empty</code>).<h2 id=discriminants>Discriminants</h2><p>Let me quickly introduce the concept of discriminants, which I’ll be making heavy use of in this post. I’m not talking about the discriminants you might be familiar with from linear algebra, but rather the more general concept of a feature that enables things to be distinguished from one another. For example, crocodiles and alligators are often mistaken for one another but you can easily tell them apart by observing the shape of the snout; crocodiles are long and pointy whereas alligators have shorter, rounder ones.<p>Translating a concept like “snout shape” to a computer model is something that is well-suited to machine learning algorithms, but concepts like “pixel color” or “number of pixels in a region matching a predicate” are much simpler to implement, deterministic, and more performant to run. You might even remember that I already used one in the last <a href=../dnd-pt1/#parsing-preparation>post</a> to find the offset of the game window using a 3-pixel pattern. In the next few sections I’ll cover the the choice and application of discriminants to parse tile states, wall counts, and the seed.<h2 id=parsing-the-tiles>Parsing the Tiles</h2><p>Recall that I only need to determine which of three states a tile is in. It was pretty straightforward to tell if a tile is <code>Empty</code> by comparing the tile to the static background image. From there, I suspected I could tell whether it was <code>Treasure</code> or <code>Monster</code> by comparing the pixel colors from each of the sprites. I theorized that if I overlaid images of all the monster sprites with the treasure sprite, I could find at least one pixel which satisfies the following constraints:<ol><li>It is opaque every sprite <a name=constraints></a><li>Its color for each monster is not equal to the treasure chest<li>Its color for each monster is not equal to the background color</ol><p>More formally, I hoped to find a position <em>p</em> within the 32x32 pixel sprite such that the colors for all the monsters at <em>p</em> and the color for the treasure sprite at <em>p</em> form a disjoint set. If such a case could be found, the tile parsing discriminant would be a single pixel and the parsing code would be but a morsel.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#db784d>match</span><span> pixel {
</span><span>    background_color </span><span style=color:#db784d>=> </span><span>Tile::Empty,
</span><span>    treasure_color </span><span style=color:#db784d>=> </span><span>Tile::Treasure,
</span><span>    </span><span style=color:#db784d>_ => </span><span>Tile::Monster,
</span><span>}
</span></code></pre><p>Computing the tile discriminant turned out to be quite involved. I have left the details to a separate bonus <a href=../dnd-pt2-5/>post</a> covering texture decoding, sprite registration (alignment), and use of <code>imagemagick</code>, a command-line image editing tool. It’s not required reading but it contains a proof for the following statement which is important for rest of the post:<blockquote><p>Sampling a single pixel in a in a tile with offset (16, 12) yields enough information to tell whether it contains a monster, treasure, or nothing.</blockquote><p>There was one small catch, which is that the background color at that offset varies for each tile. I fixed this by building a lookup table containing the color at (16, 12) for each tile.<div class=textCenter><a class=img-link href=background_pixels.webp><img alt="Background pixels" src=background_pixels.webp></a><div class=caption>Left: The pixels with (16, 12) offset in each tile are highlighted. Right: The 64 pixels extracted into a single image.</div><br></div><p>I extracted these 64 sample pixels and stored them in a <code>const</code> array, alongside the color of the treasure sprite at the same offset. Each pixel is 4 bytes, represented as <code>[u8; 4]</code>.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#95cc5e>const </span><span style=color:#db784d>TREASURE_COLOR</span><span>: [</span><span style=color:#95cc5e>u8</span><span>; </span><span style=color:#eaae2e>4</span><span>] </span><span style=color:#db784d>= </span><span>[</span><span style=color:#eaae2e>220</span><span>, </span><span style=color:#eaae2e>170</span><span>, </span><span style=color:#eaae2e>109</span><span>, </span><span style=color:#eaae2e>255</span><span>];
</span><span style=color:#95cc5e>const </span><span style=color:#db784d>BACKGROUND_PIXELS</span><span>: [[[</span><span style=color:#95cc5e>u8</span><span>; </span><span style=color:#eaae2e>4</span><span>]; </span><span style=color:#eaae2e>8</span><span>]; </span><span style=color:#eaae2e>8</span><span>] </span><span style=color:#db784d>= </span><span>[
</span><span>    [
</span><span>        [</span><span style=color:#eaae2e>176</span><span>, </span><span style=color:#eaae2e>128</span><span>, </span><span style=color:#eaae2e>93</span><span>, </span><span style=color:#eaae2e>255</span><span>], [</span><span style=color:#eaae2e>55</span><span>, </span><span style=color:#eaae2e>58</span><span>, </span><span style=color:#eaae2e>59</span><span>, </span><span style=color:#eaae2e>255</span><span>],
</span><span>        [</span><span style=color:#eaae2e>125</span><span>, </span><span style=color:#eaae2e>113</span><span>, </span><span style=color:#eaae2e>90</span><span>, </span><span style=color:#eaae2e>255</span><span>], [</span><span style=color:#eaae2e>54</span><span>, </span><span style=color:#eaae2e>58</span><span>, </span><span style=color:#eaae2e>55</span><span>, </span><span style=color:#eaae2e>255</span><span>],
</span><span>        [</span><span style=color:#eaae2e>176</span><span>, </span><span style=color:#eaae2e>128</span><span>, </span><span style=color:#eaae2e>93</span><span>, </span><span style=color:#eaae2e>255</span><span>], [</span><span style=color:#eaae2e>55</span><span>, </span><span style=color:#eaae2e>58</span><span>, </span><span style=color:#eaae2e>59</span><span>, </span><span style=color:#eaae2e>255</span><span>],
</span><span>        [</span><span style=color:#eaae2e>125</span><span>, </span><span style=color:#eaae2e>113</span><span>, </span><span style=color:#eaae2e>90</span><span>, </span><span style=color:#eaae2e>255</span><span>], [</span><span style=color:#eaae2e>54</span><span>, </span><span style=color:#eaae2e>58</span><span>, </span><span style=color:#eaae2e>55</span><span>, </span><span style=color:#eaae2e>255</span><span>],
</span><span>    ],
</span><span>    </span><span style=color:#7a7267>// for brevity, only 8 pixel values are shown here
</span><span>];
</span></code></pre><p>Now I could loop over each tile, compute the offset of the sample points, and then check against the background/treasure colors to determine the contents of the cell.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#7a7267>// Input image is a cropped view of only the tiles
</span><span style=color:#95cc5e>fn </span><span style=color:#60a365>parse_tiles</span><span>(</span><span style=font-style:italic;color:#f8bb39>img</span><span>: SubImage<</span><span style=color:#db784d>&</span><span>RgbaImage>) -> [[Tile; </span><span style=color:#eaae2e>8</span><span>]; </span><span style=color:#eaae2e>8</span><span>] {
</span><span>    </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> tiles </span><span style=color:#db784d>= </span><span>[[Tile::Empty; </span><span style=color:#eaae2e>8</span><span>]; </span><span style=color:#eaae2e>8</span><span>];
</span><span>    </span><span style=color:#db784d>for</span><span> tile_y </span><span style=color:#db784d>in </span><span style=color:#eaae2e>0</span><span style=color:#db784d>..</span><span style=color:#eaae2e>8</span><span style=color:#95cc5e>usize </span><span>{
</span><span>        </span><span style=color:#db784d>for</span><span> tile_x </span><span style=color:#db784d>in </span><span style=color:#eaae2e>0</span><span style=color:#db784d>..</span><span style=color:#eaae2e>8</span><span style=color:#95cc5e>usize </span><span>{
</span><span>            </span><span style=color:#7a7267>// Lookup the background color for the current tile
</span><span>            </span><span style=color:#95cc5e>let</span><span> bg_color </span><span style=color:#db784d>= BACKGROUND_PIXELS</span><span>[tile_y][tile_x];
</span><span>            </span><span style=color:#95cc5e>let</span><span> px </span><span style=color:#db784d>=</span><span> tile_x </span><span style=color:#db784d>as </span><span style=color:#95cc5e>u32 </span><span style=color:#db784d>* TILE_STRIDE + TILE_SAMPLE_POINT</span><span>.</span><span style=color:#eaae2e>0</span><span>;
</span><span>            </span><span style=color:#95cc5e>let</span><span> py </span><span style=color:#db784d>=</span><span> tile_y </span><span style=color:#db784d>as </span><span style=color:#95cc5e>u32 </span><span style=color:#db784d>* TILE_STRIDE + TILE_SAMPLE_POINT</span><span>.</span><span style=color:#eaae2e>1</span><span>;
</span><span>            
</span><span>            </span><span style=color:#7a7267>// Fetch the color at the tile's sample point
</span><span>            </span><span style=color:#95cc5e>let</span><span> sample </span><span style=color:#db784d>=</span><span> img.</span><span style=color:#95cc5e>get_pixel</span><span>(px, py).</span><span style=color:#eaae2e>0</span><span>;
</span><span>
</span><span>            </span><span style=color:#7a7267>// #computervision
</span><span>            </span><span style=color:#db784d>if</span><span> sample </span><span style=color:#db784d>==</span><span> bg_color {
</span><span>                tiles[tile_y][tile_x] </span><span style=color:#db784d>= </span><span>Tile::Empty;
</span><span>            } </span><span style=color:#db784d>else if</span><span> sample </span><span style=color:#db784d>== TREASURE_COLOR </span><span>{
</span><span>                tiles[tile_y][tile_x] </span><span style=color:#db784d>= </span><span>Tile::Treasure;
</span><span>            } </span><span style=color:#db784d>else </span><span>{
</span><span>                tiles[tile_y][tile_x] </span><span style=color:#db784d>= </span><span>Tile::Monster;
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    tiles
</span><span>}
</span></code></pre><p>This logic turned out to be surprisingly simple and reminded me of the <a href="https://www.youtube.com/watch?v=tWwCK95X6go" rel=noopener target=_blank>hotdog, not hotdog</a> (warning: language) sketch from the show Silicon Valley.<p>Now I was ready to finally test it out. I wrote a function to overlay the detected state on the screenshot with red being a monster and green being a treasure, and generate a bunch of random puzzles to test it. The overlay was nice because I didn’t have to look at a bunch of debug text on the command line.</p><center> <video alt="Successful parsing" onclick="this.paused ? this.play() : this.pause();" autoplay loop src=parsing.webm></video> <div class=caption>100 random puzzles with the parsed state overlaid.</div> </center><h2 id=reading-numbers>Reading Numbers</h2><p>With tile parsing out of the way, I could get started on the numbers along the edge of the board. These numbers give crucial information to the player about how many walls should be placed in each row and column. Unlike the tiles where I only had 3 states to discern, there are 9 digits in two colors each that might show up in a puzzle, which is 18 potential states. Having more states and less color variability means my discriminant will likely need to be more than one pixel.<div class=textCenter><a class=img-link href=numbers.webp><img alt=Digits src=numbers.webp></a><div class=caption>The digit sprites. The red color indicates that row or column doesn't have the correct number of walls placed.</div><br></div><p>I could whittle this down however by carefully considering the mechanics of the game. The brown numbers indicate a satisfied constraint (the correct number of walls in that row/column) and red represents an unsatisfied constraint. Considering any new puzzle will have no walls placed, the following must be true:<ul><li>Any <code>0</code> digits must be brown, because with no walls placed they will be satisfied<li>Any <code>1</code> through <code>8</code> digits must be red, because with no walls placed they will be unsatisfied</ul><p>Additionally, after exploring a few thousand random puzzles, I never once came across an <code>8</code> on the board, so I assume the developer explicitly forbid this from the level generator as it effectively just creates smaller, less interesting puzzles. To summarize, the only digits I will see on a new board are brown <code>0</code> and red <code>1</code> through <code>7</code>. A total of 8 possible states to look out for. To begin parsing, I started by isolating the pixels of the digits from the rest of the game with a threshold filter.<div class=textCenter><a class=img-link href=threshold.webp><img alt="Game image, thresholded." src=threshold.webp></a><div class=caption>Center: RGB values of the digits. Right: Game masked to only allow pixels with green = 91 and 69 < blue < 77.</div><br></div><p>The brown and red digits coincidentally had equivalent green values, and pretty similar blue values which let me produce a tight threshold that accurately excised the numbers from the background. With the isolated pixels I decided to try counting the number of pixels for each digit to see if they each had a unique count I could key off. I only used the top half of the bounding box so as to avoid large monster sprites covering up the bottom half of the numbers and throwing the results off. My function produced the following output.<blockquote><p>[102, 54, 82, 68, 84, 94, 64, 72]</blockquote><p>These are the pixel counts for each digit from 0 on the left to 7 on the right. Thankfully they were all unique which meant I could map these counts directly to the digits they represent. The only caveat is that it required checking 22x16=352 pixels per digit. With 16 digits it came to over 5600 pixels to check and I wanted to minimize that. I wrote another function, this time to count the pixels with an iteratively shrinking region to try and identify the smallest possible region that could still uniquely identify all 8 digits.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#db784d>pub </span><span style=color:#95cc5e>fn </span><span style=color:#60a365>get_large_digit_discriminant</span><span>() {
</span><span>    </span><span style=color:#95cc5e>let</span><span> digits_img </span><span style=color:#db784d>= </span><span>image::open(</span><span style=color:#db784d>LARGE_FONT_PATH</span><span>).</span><span style=color:#95cc5e>unwrap</span><span>();
</span><span>
</span><span>    </span><span style=color:#7a7267>// Extract individual digits (brown 0, red 1-7)
</span><span>    </span><span style=color:#95cc5e>let</span><span> digits_imgs </span><span style=color:#db784d>= </span><span>[</span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#eaae2e>1</span><span>, </span><span style=color:#eaae2e>2</span><span>, </span><span style=color:#eaae2e>3</span><span>, </span><span style=color:#eaae2e>4</span><span>, </span><span style=color:#eaae2e>5</span><span>, </span><span style=color:#eaae2e>6</span><span>, </span><span style=color:#eaae2e>7</span><span>].</span><span style=color:#95cc5e>map</span><span>(|</span><span style=font-style:italic;color:#f8bb39>i</span><span>| {
</span><span>        digits_img.</span><span style=color:#95cc5e>view</span><span>(
</span><span>            </span><span style=color:#db784d>DIGIT_OFFSETS</span><span>[i],
</span><span>            </span><span style=color:#db784d>if</span><span> i </span><span style=color:#db784d>== </span><span style=color:#eaae2e>0 </span><span>{ </span><span style=color:#eaae2e>32 </span><span>} </span><span style=color:#db784d>else </span><span>{ </span><span style=color:#eaae2e>0 </span><span>},
</span><span>            </span><span style=color:#db784d>MAX_PATTERN_WIDTH</span><span>,
</span><span>            </span><span style=color:#db784d>MAX_PATTERN_HEIGHT</span><span>,
</span><span>        )
</span><span>    });
</span><span>
</span><span>    </span><span style=color:#db784d>for </span><span>(i, digit) </span><span style=color:#db784d>in</span><span> digits_imgs.</span><span style=color:#95cc5e>iter</span><span>().</span><span style=color:#95cc5e>enumerate</span><span>() {
</span><span>        digit
</span><span>            .</span><span style=color:#95cc5e>to_image</span><span>()
</span><span>            .</span><span style=color:#95cc5e>save</span><span>(format!(</span><span style=color:#eaae2e>"script_output/digit_discrim/</span><span style=color:#db784d>{i}</span><span style=color:#eaae2e>.png"</span><span>))
</span><span>            .</span><span style=color:#95cc5e>unwrap</span><span>();
</span><span>    }
</span><span>    </span><span style=color:#7a7267>// Create a window with size 'len' and move it across each digit
</span><span>    </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> best_size </span><span style=color:#db784d>= </span><span style=color:#95cc5e>u32</span><span>::</span><span style=color:#db784d>MAX</span><span>;
</span><span>    </span><span style=color:#7a7267>// Iterate over windows of varying sizes
</span><span>    </span><span style=color:#db784d>for</span><span> width </span><span style=color:#db784d>in </span><span>(</span><span style=color:#eaae2e>1</span><span style=color:#db784d>..=MAX_PATTERN_WIDTH</span><span>).</span><span style=color:#95cc5e>rev</span><span>() {
</span><span>        </span><span style=color:#db784d>for</span><span> height </span><span style=color:#db784d>in </span><span>(</span><span style=color:#eaae2e>1</span><span style=color:#db784d>..=MAX_PATTERN_HEIGHT</span><span>).</span><span style=color:#95cc5e>rev</span><span>() {
</span><span>            </span><span style=color:#7a7267>// I need a minimum of 8 pixels in the region
</span><span>            </span><span style=color:#db784d>if</span><span> width </span><span style=color:#db784d>*</span><span> height </span><span style=color:#db784d>< </span><span style=color:#eaae2e>8 </span><span>{
</span><span>                </span><span style=color:#db784d>continue</span><span>;
</span><span>            }
</span><span>            </span><span style=color:#7a7267>// Iterate over all positions
</span><span>            </span><span style=color:#db784d>for</span><span> y </span><span style=color:#db784d>in </span><span style=color:#eaae2e>0</span><span style=color:#db784d>..=MAX_PATTERN_HEIGHT -</span><span> height {
</span><span>                </span><span style=color:#db784d>for</span><span> x </span><span style=color:#db784d>in </span><span style=color:#eaae2e>0</span><span style=color:#db784d>..=MAX_PATTERN_WIDTH -</span><span> width {
</span><span>                    </span><span style=color:#7a7267>// Count digits in the region that pass threshold filter
</span><span>                    </span><span style=color:#95cc5e>let</span><span> counts </span><span style=color:#db784d>= </span><span>[</span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#eaae2e>1</span><span>, </span><span style=color:#eaae2e>2</span><span>, </span><span style=color:#eaae2e>3</span><span>, </span><span style=color:#eaae2e>4</span><span>, </span><span style=color:#eaae2e>5</span><span>, </span><span style=color:#eaae2e>6</span><span>, </span><span style=color:#eaae2e>7</span><span>].</span><span style=color:#95cc5e>map</span><span>(|</span><span style=font-style:italic;color:#f8bb39>i</span><span>| {
</span><span>                        digits_imgs[i]
</span><span>                            .</span><span style=color:#95cc5e>view</span><span>(x, y, width, height)
</span><span>                            .</span><span style=color:#95cc5e>pixels</span><span>()
</span><span>                            .</span><span style=color:#95cc5e>map</span><span>(|(_, _, </span><span style=font-style:italic;color:#f8bb39>p</span><span>)| p.</span><span style=color:#eaae2e>0</span><span>) </span><span style=color:#7a7267>// destructure the pixel
</span><span>                            .</span><span style=color:#95cc5e>filter</span><span>(|</span><span style=font-style:italic;color:#f8bb39>p</span><span>| p[</span><span style=color:#eaae2e>1</span><span>] </span><span style=color:#db784d>== </span><span style=color:#eaae2e>91 </span><span style=color:#db784d>&&</span><span> p[</span><span style=color:#eaae2e>2</span><span>] </span><span style=color:#db784d>>= </span><span style=color:#eaae2e>69 </span><span style=color:#db784d>&&</span><span> p[</span><span style=color:#eaae2e>2</span><span>] </span><span style=color:#db784d><= </span><span style=color:#eaae2e>78</span><span>)
</span><span>                            .</span><span style=color:#95cc5e>count</span><span>()
</span><span>                    });
</span><span>                    </span><span style=color:#7a7267>// Check that the counts are unique
</span><span>                    </span><span style=color:#95cc5e>let</span><span> unique_count </span><span style=color:#db784d>= </span><span>HashSet::from(counts).</span><span style=color:#95cc5e>len</span><span>();
</span><span>                    </span><span style=color:#db784d>if</span><span> unique_count </span><span style=color:#db784d>>= </span><span style=color:#eaae2e>8 </span><span>{
</span><span>                        </span><span style=color:#db784d>if</span><span> width </span><span style=color:#db784d>*</span><span> height </span><span style=color:#db784d><</span><span> best_size {
</span><span>                            best_size </span><span style=color:#db784d>=</span><span> width </span><span style=color:#db784d>*</span><span> height;
</span><span>                            println!(</span><span style=color:#eaae2e>"</span><span style=color:#db784d>{width}</span><span style=color:#eaae2e>x</span><span style=color:#db784d>{height}</span><span style=color:#eaae2e>+</span><span style=color:#db784d>{x}</span><span style=color:#eaae2e>+</span><span style=color:#db784d>{y}</span><span style=color:#eaae2e>"</span><span>);
</span><span>                            println!(</span><span style=color:#eaae2e>"  </span><span style=color:#db784d>{counts:?}</span><span style=color:#eaae2e>"</span><span>);
</span><span>                        }
</span><span>                    }
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>} </span><span style=color:#7a7267>// wheeee!
</span></code></pre><p>I added a bit of extra code not shown here to output frames to an animation showing the refinement of the discrimination region.</p><center> <video alt="Digit discrimination animation" onclick="this.paused ? this.play() : this.pause();" autoplay loop src=digit_discrim.webm></video> <div class=caption>Refining the discriminant region for the digits after thresholding.</div> </center><p>Looking at just the just the last frame of the animation, you can see quite easily that each blue region contains a unique number of white pixels.<div class=textCenter><a class=img-link href=digit_discrim.webp><img alt="Digit discrimination" src=digit_discrim.webp></a><div class=caption>Each digit has a unique number of white pixels in the search region.</div><br></div><p>The output of the function told me that the region has a size of 2x4 pixels with an offset of (3, 11). The counts for each digit are:<table><thead><tr><th>Digit<th>0<th>1<th>2<th>3<th>4<th>5<th>6<th>7<tbody><tr><td>Count<td>4<td>0<td>5<td>2<td>3<td>8<td>6<td>1</table><p>I slapped this into a <code>match</code> statement and boom! Optical character recognition!<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#7a7267>// Map the discriminant values to the digits they represent
</span><span style=color:#95cc5e>fn </span><span style=color:#60a365>count_to_digit</span><span>(</span><span style=font-style:italic;color:#f8bb39>count</span><span>: </span><span style=color:#95cc5e>usize</span><span>) -> </span><span style=font-style:italic;color:#db784d>Result</span><span><</span><span style=color:#95cc5e>u8</span><span>> {
</span><span>    </span><span style=font-style:italic;color:#db784d>Ok</span><span>(</span><span style=color:#db784d>match</span><span> count {
</span><span>        </span><span style=color:#eaae2e>4 </span><span style=color:#db784d>=> </span><span style=color:#eaae2e>0</span><span style=color:#95cc5e>u8</span><span>,
</span><span>        </span><span style=color:#eaae2e>0 </span><span style=color:#db784d>=> </span><span style=color:#eaae2e>1</span><span>,
</span><span>        </span><span style=color:#eaae2e>5 </span><span style=color:#db784d>=> </span><span style=color:#eaae2e>2</span><span>,
</span><span>        </span><span style=color:#eaae2e>2 </span><span style=color:#db784d>=> </span><span style=color:#eaae2e>3</span><span>,
</span><span>        </span><span style=color:#eaae2e>3 </span><span style=color:#db784d>=> </span><span style=color:#eaae2e>4</span><span>,
</span><span>        </span><span style=color:#eaae2e>8 </span><span style=color:#db784d>=> </span><span style=color:#eaae2e>5</span><span>,
</span><span>        </span><span style=color:#eaae2e>6 </span><span style=color:#db784d>=> </span><span style=color:#eaae2e>6</span><span>,
</span><span>        </span><span style=color:#eaae2e>1 </span><span style=color:#db784d>=> </span><span style=color:#eaae2e>7</span><span>,
</span><span>        </span><span style=color:#db784d>_ => return </span><span style=font-style:italic;color:#db784d>Err</span><span>(anyhow!(</span><span style=color:#eaae2e>"Error parsing digit"</span><span>)),
</span><span>    })
</span><span>}
</span><span>
</span><span style=color:#95cc5e>const </span><span style=color:#db784d>SAMPLE_OFFSET</span><span>: (</span><span style=color:#95cc5e>u32</span><span>, </span><span style=color:#95cc5e>u32</span><span>) </span><span style=color:#db784d>= </span><span>(</span><span style=color:#eaae2e>3</span><span>, </span><span style=color:#eaae2e>11</span><span>);  </span><span style=color:#7a7267>// From above computation
</span><span style=color:#95cc5e>const </span><span style=color:#db784d>SAMPLE_SIZE</span><span>: (</span><span style=color:#95cc5e>u32</span><span>, </span><span style=color:#95cc5e>u32</span><span>) </span><span style=color:#db784d>= </span><span>(</span><span style=color:#eaae2e>4</span><span>, </span><span style=color:#eaae2e>2</span><span>);     </span><span style=color:#7a7267>// From above computation
</span><span style=color:#95cc5e>const </span><span style=color:#db784d>TILE_STRIDE</span><span>: </span><span style=color:#95cc5e>u32 </span><span style=color:#db784d>= </span><span style=color:#eaae2e>33</span><span>;                </span><span style=color:#7a7267>// Spacing between digits
</span><span style=color:#95cc5e>const </span><span style=color:#db784d>TOP_NUMS_OFFSETS</span><span>: [</span><span style=color:#95cc5e>u32</span><span>; </span><span style=color:#eaae2e>8</span><span>] </span><span style=color:#db784d>= </span><span>[</span><span style=color:#eaae2e>1</span><span>, </span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#eaae2e>0</span><span>];
</span><span style=color:#95cc5e>const </span><span style=color:#db784d>LEFT_NUMS_OFFSETS</span><span>: [</span><span style=color:#95cc5e>u32</span><span>; </span><span style=color:#eaae2e>8</span><span>] </span><span style=color:#db784d>= </span><span>[</span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#eaae2e>2</span><span>, </span><span style=color:#eaae2e>2</span><span>, </span><span style=color:#eaae2e>1</span><span>, </span><span style=color:#eaae2e>1</span><span>, </span><span style=color:#eaae2e>2</span><span>, </span><span style=color:#eaae2e>2</span><span>, </span><span style=color:#eaae2e>1</span><span>];
</span><span>
</span><span style=color:#7a7267>// Pass in two subimages cropped to the numbers on the top and left sides
</span><span style=color:#95cc5e>fn </span><span style=color:#60a365>parse_wall_counts</span><span>(
</span><span>    </span><span style=font-style:italic;color:#f8bb39>top_img</span><span>: SubImage<</span><span style=color:#db784d>&</span><span>RgbaImage>,
</span><span>    </span><span style=font-style:italic;color:#f8bb39>left_img</span><span>: SubImage<</span><span style=color:#db784d>&</span><span>RgbaImage>,
</span><span>) -> </span><span style=font-style:italic;color:#db784d>Result</span><span><([</span><span style=color:#95cc5e>u8</span><span>; 8], [</span><span style=color:#95cc5e>u8</span><span>; 8])> {
</span><span>    </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> top_nums </span><span style=color:#db784d>= </span><span>[</span><span style=color:#eaae2e>0</span><span>; </span><span style=color:#eaae2e>8</span><span>];
</span><span>    </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> left_nums </span><span style=color:#db784d>= </span><span>[</span><span style=color:#eaae2e>0</span><span>; </span><span style=color:#eaae2e>8</span><span>];
</span><span>    </span><span style=color:#db784d>for</span><span> i </span><span style=color:#db784d>in </span><span style=color:#eaae2e>0</span><span style=color:#db784d>..</span><span style=color:#eaae2e>8 </span><span>{
</span><span>        </span><span style=color:#7a7267>// Crop the image to a single digit, threshold, and count pixels
</span><span>        </span><span style=color:#95cc5e>let</span><span> top_x </span><span style=color:#db784d>=</span><span> i </span><span style=color:#db784d>* TILE_STRIDE + </span><span style=color:#eaae2e>3 </span><span style=color:#db784d>+ TOP_NUMS_OFFSETS</span><span>[i </span><span style=color:#db784d>as </span><span style=color:#95cc5e>usize</span><span>];
</span><span>        </span><span style=color:#95cc5e>let</span><span> top_y </span><span style=color:#db784d>= </span><span style=color:#eaae2e>11</span><span>;
</span><span>        </span><span style=color:#95cc5e>let</span><span> top_count </span><span style=color:#db784d>=</span><span> top_img
</span><span>            .</span><span style=color:#95cc5e>view</span><span>(top_x, top_y, </span><span style=color:#eaae2e>4</span><span>, </span><span style=color:#eaae2e>2</span><span>)   </span><span style=color:#7a7267>//
</span><span>            .</span><span style=color:#95cc5e>pixels</span><span>()
</span><span>            .</span><span style=color:#95cc5e>map</span><span>(|(_, _, </span><span style=font-style:italic;color:#f8bb39>p</span><span>)| p.</span><span style=color:#eaae2e>0</span><span>)
</span><span>            .</span><span style=color:#95cc5e>filter</span><span>(|</span><span style=color:#db784d>&</span><span>[</span><span style=font-style:italic;color:#f8bb39>_r</span><span>, </span><span style=font-style:italic;color:#f8bb39>g</span><span>, </span><span style=font-style:italic;color:#f8bb39>b</span><span>, _a]</span><span style=color:#db784d>|</span><span> g </span><span style=color:#db784d>== </span><span style=color:#eaae2e>91 </span><span style=color:#db784d>&&</span><span> b </span><span style=color:#db784d>>= </span><span style=color:#eaae2e>69 </span><span style=color:#db784d>&&</span><span> b </span><span style=color:#db784d><= </span><span style=color:#eaae2e>78</span><span>)
</span><span>            .</span><span style=color:#95cc5e>count</span><span>();
</span><span>
</span><span>        </span><span style=color:#7a7267>// Repeat for the numbers on the left side
</span><span>        </span><span style=color:#95cc5e>let</span><span> left_x </span><span style=color:#db784d>= </span><span style=color:#eaae2e>3</span><span>;
</span><span>        </span><span style=color:#95cc5e>let</span><span> left_y </span><span style=color:#db784d>=</span><span> i </span><span style=color:#db784d>* TILE_STRIDE + </span><span style=color:#eaae2e>11 </span><span style=color:#db784d>+ LEFT_NUMS_OFFSETS</span><span>[i </span><span style=color:#db784d>as </span><span style=color:#95cc5e>usize</span><span>];
</span><span>        </span><span style=color:#95cc5e>let</span><span> left_count </span><span style=color:#db784d>=</span><span> left_img
</span><span>            .</span><span style=color:#95cc5e>view</span><span>(left_x, left_y, </span><span style=color:#eaae2e>4</span><span>, </span><span style=color:#eaae2e>2</span><span>)
</span><span>            .</span><span style=color:#95cc5e>pixels</span><span>()
</span><span>            .</span><span style=color:#95cc5e>map</span><span>(|(_, _, </span><span style=font-style:italic;color:#f8bb39>p</span><span>)| p.</span><span style=color:#eaae2e>0</span><span>)
</span><span>            .</span><span style=color:#95cc5e>filter</span><span>(|</span><span style=color:#db784d>&</span><span>[</span><span style=font-style:italic;color:#f8bb39>_r</span><span>, </span><span style=font-style:italic;color:#f8bb39>g</span><span>, </span><span style=font-style:italic;color:#f8bb39>b</span><span>, _a]</span><span style=color:#db784d>|</span><span> g </span><span style=color:#db784d>== </span><span style=color:#eaae2e>91 </span><span style=color:#db784d>&&</span><span> b </span><span style=color:#db784d>>= </span><span style=color:#eaae2e>69 </span><span style=color:#db784d>&&</span><span> b </span><span style=color:#db784d><= </span><span style=color:#eaae2e>78</span><span>)
</span><span>            .</span><span style=color:#95cc5e>count</span><span>();
</span><span>
</span><span>        </span><span style=color:#7a7267>// Map the counts to digits using the discriminant values
</span><span>        top_nums[i </span><span style=color:#db784d>as </span><span style=color:#95cc5e>usize</span><span>] </span><span style=color:#db784d>= </span><span style=color:#95cc5e>count_to_digit</span><span>(top_count)</span><span style=color:#db784d>?</span><span>;
</span><span>        left_nums[i </span><span style=color:#db784d>as </span><span style=color:#95cc5e>usize</span><span>] </span><span style=color:#db784d>= </span><span style=color:#95cc5e>count_to_digit</span><span>(left_count)</span><span style=color:#db784d>?</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style=font-style:italic;color:#db784d>Ok</span><span>((top_nums, left_nums))
</span><span>}
</span></code></pre><p>You may have also noticed the definition of <code>TOP_NUMS_OFFSETS</code> and <code>LEFT_NUMS_OFFSETS</code>. When I first ran this it wasn’t giving proper results until I realized the digit sprites have an extra offset when drawn to screen and don’t follow a perfect grid. Each one is jittered by 0-2 pixels. I computed these offsets manually and added them back into the coordinate computation to fix it. I modified my parsing overlay function to also show the numbers my program thought it was seeing.</p><center> <video alt="Successful parsing2" onclick="this.paused ? this.play() : this.pause();" autoplay loop src=parsing2.webm></video> <div class=caption>100 more random puzzles with the parsed state overlaid, including wall counts.</div> </center><h2 id=harvesting-the-seed>Harvesting the Seed</h2><p>The last piece of the puzzle is the room seed. It’s an 8 digit number above the puzzle that can be used to revisit puzzles you’ve played in the past. I want to build a simple database of puzzles which I can reuse for testing without relying on image parsing or even having the game running all the time, and the seed will serve to let me remove duplicates. It can also be used as a small easy-to-copy type which I can pass around without dragging the rest of the puzzle data with it. Let’s take a look at the font and separate it from the background like we did with the wall counts.<div class=textCenter><a class=img-link href=seeds.webp><img alt="Seed thresholding" src=seeds.webp></a><div class=caption>A bunch of random seeds. On the right the image is thresholded with red = 122.</div><br></div><p>I’ll zoom in on the font a bit more so you can see some of the observations I made.<div class=textCenter><a class=img-link href=font_small.webp><img alt="Small font" src=font_small.webp></a><div class=caption>Enhance!</div><br></div><p>What I noticed:<ol><li>The font is non-monospaced (polyspaced?)<li>The text appears to be center-justified<li>There is exactly 1 pixel of spacing between characters<li>The pixels are all 7 pixels tall and between 4 and 7 pixels wide<li>The leftmost column of pixels forms a unique pattern for each digit</ol><p>The last observation turned out to be the key to success. To elaborate on the idea, consider the first digit, <code>0</code>. The column reads from top to bottom 0, 0, 1, 1, 1, 0, 0. If we combine these bits into a binary number 0b0011100, it corresponds to a value of 28 which I’ll call its <em>hash</em>. Moving to the next digit, we get 0b0100001 which is 33. 2 has a hash of 17, and so on.<div class=textCenter><a class=img-link href=font_small_highlighted.webp><img alt="Small font2" src=font_small_highlighted.webp></a><div class=caption>The same font, but with the first column of each digit highlighted in blue.</div><br></div><p>For completeness, here’s the full table:<table><thead><tr><th>Digit<th>0<th>1<th>2<th>3<th>4<th>5<th>6<th>7<tbody><tr><td>Hash<td>28<td>33<td>17<td>18<td>8<td>122<td>62<td>16</table><p>Fortunately for me, each of these hashes is unique which meant I could use them as the discriminant to parse the seed. I developed a simple algorithm to complete this task.<ol><li>Starting from the left, consider a column of 7 pixels, thresholded to be either black or white<li>Read the pixels from top to bottom as a 7-bit binary number <em>n</em>, and call this the hash<li>Look up the hash in a table to identify which digit we’re looking at and how many columns to advance<li>Accumulate each digit into a single variable</ol><p>For step 3, I needed a table which had each digit’s width so I could skip ahead each time I identified a digit. I just counted the pixels manually and added 1 for the extra space between characters, tabulating them in an array.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#7a7267>// Width of each digit + 1 (to include the kerning)
</span><span style=color:#95cc5e>const </span><span style=color:#db784d>SEED_OFFSETS</span><span>: [</span><span style=color:#95cc5e>u32</span><span>; </span><span style=color:#eaae2e>10</span><span>] </span><span style=color:#db784d>= </span><span>[</span><span style=color:#eaae2e>8</span><span>, </span><span style=color:#eaae2e>5</span><span>, </span><span style=color:#eaae2e>8</span><span>, </span><span style=color:#eaae2e>8</span><span>, </span><span style=color:#eaae2e>7</span><span>, </span><span style=color:#eaae2e>8</span><span>, </span><span style=color:#eaae2e>8</span><span>, </span><span style=color:#eaae2e>8</span><span>, </span><span style=color:#eaae2e>8</span><span>, </span><span style=color:#eaae2e>8</span><span>];
</span></code></pre><p>Parsing the seed is then pretty easy. See for yourself!<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#95cc5e>const </span><span style=color:#db784d>SEED_BASE</span><span>: (</span><span style=color:#95cc5e>u32</span><span>, </span><span style=color:#95cc5e>u32</span><span>) </span><span style=color:#db784d>= </span><span>(</span><span style=color:#eaae2e>109</span><span>, </span><span style=color:#eaae2e>103</span><span>);   </span><span style=color:#7a7267>// Offset to top-left pixel of seed
</span><span style=color:#95cc5e>const </span><span style=color:#db784d>SEED_SIZE</span><span>: (</span><span style=color:#95cc5e>u32</span><span>, </span><span style=color:#95cc5e>u32</span><span>) </span><span style=color:#db784d>= </span><span>(</span><span style=color:#eaae2e>63</span><span>, </span><span style=color:#eaae2e>7</span><span>);      </span><span style=color:#7a7267>// Size of full seed in pixels
</span><span style=color:#95cc5e>fn </span><span style=color:#60a365>parse_seed</span><span>(</span><span style=font-style:italic;color:#f8bb39>img</span><span>: SubImage<</span><span style=color:#db784d>&</span><span>RgbaImage>) -> </span><span style=font-style:italic;color:#db784d>Result</span><span><</span><span style=font-style:italic;color:#db784d>Option</span><span><</span><span style=color:#95cc5e>u32</span><span>>> {
</span><span>    </span><span style=color:#7a7267>// Parse seed
</span><span>    </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> seed </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0</span><span style=color:#95cc5e>u32</span><span>;
</span><span>    </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> seed_present </span><span style=color:#db784d>= false</span><span>;
</span><span>    </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> x </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0</span><span>;
</span><span>
</span><span>    </span><span style=color:#7a7267>// Scan from the left
</span><span>    </span><span style=color:#db784d>while</span><span> x </span><span style=color:#db784d>< SEED_SIZE</span><span>.</span><span style=color:#eaae2e>0 </span><span>{
</span><span>        </span><span style=color:#7a7267>// Extract a column and compute the hash
</span><span>        </span><span style=color:#95cc5e>let</span><span> hash </span><span style=color:#db784d>=</span><span> img
</span><span>            .</span><span style=color:#95cc5e>view</span><span>(x, </span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#eaae2e>1</span><span>, </span><span style=color:#db784d>SEED_SIZE</span><span>.</span><span style=color:#eaae2e>1</span><span>)
</span><span>            .</span><span style=color:#95cc5e>pixels</span><span>()
</span><span>            .</span><span style=color:#95cc5e>map</span><span>(|(</span><span style=font-style:italic;color:#f8bb39>_x</span><span>, </span><span style=font-style:italic;color:#f8bb39>_y</span><span>, </span><span style=font-style:italic;color:#f8bb39>Rgba</span><span>([</span><span style=font-style:italic;color:#f8bb39>r</span><span>, </span><span style=font-style:italic;color:#f8bb39>_g</span><span>, </span><span style=font-style:italic;color:#f8bb39>_b</span><span>, </span><span style=font-style:italic;color:#f8bb39>_a</span><span>]))</span><span style=color:#db784d>| if</span><span> r </span><span style=color:#db784d>== </span><span style=color:#eaae2e>52 </span><span>{ </span><span style=color:#eaae2e>1 </span><span>} </span><span style=color:#db784d>else </span><span>{ </span><span style=color:#eaae2e>0 </span><span>})
</span><span>            .</span><span style=color:#95cc5e>fold</span><span>(</span><span style=color:#eaae2e>0</span><span>, |</span><span style=font-style:italic;color:#f8bb39>acc</span><span>, </span><span style=font-style:italic;color:#f8bb39>x</span><span>| (acc </span><span style=color:#db784d><< </span><span style=color:#eaae2e>1</span><span>) </span><span style=color:#db784d>+</span><span> x);
</span><span>
</span><span>        </span><span style=color:#7a7267>// Column was empty, move to the next column
</span><span>        </span><span style=color:#db784d>if</span><span> hash </span><span style=color:#db784d>== </span><span style=color:#eaae2e>0 </span><span>{
</span><span>            x </span><span style=color:#db784d>+= </span><span style=color:#eaae2e>1</span><span>;
</span><span>            </span><span style=color:#db784d>continue</span><span>;
</span><span>        }
</span><span>
</span><span>        </span><span style=color:#7a7267>// I track this to differentiate between the cases of no seed present and a seed of 00000000
</span><span>        seed_present </span><span style=color:#db784d>= true</span><span>;
</span><span>
</span><span>        </span><span style=color:#7a7267>// Map the hash back to a digit
</span><span>        </span><span style=color:#95cc5e>let</span><span> digit </span><span style=color:#db784d>= match</span><span> hash {
</span><span>            </span><span style=color:#eaae2e>28 </span><span style=color:#db784d>=> </span><span style=color:#eaae2e>0</span><span>,
</span><span>            </span><span style=color:#eaae2e>33 </span><span style=color:#db784d>=> </span><span style=color:#eaae2e>1</span><span>,
</span><span>            </span><span style=color:#eaae2e>17 </span><span style=color:#db784d>=> </span><span style=color:#eaae2e>2</span><span>,
</span><span>            </span><span style=color:#eaae2e>18 </span><span style=color:#db784d>=> </span><span style=color:#eaae2e>3</span><span>,
</span><span>            </span><span style=color:#eaae2e>8 </span><span style=color:#db784d>=> </span><span style=color:#eaae2e>4</span><span>,
</span><span>            </span><span style=color:#eaae2e>122 </span><span style=color:#db784d>=> </span><span style=color:#eaae2e>5</span><span>,
</span><span>            </span><span style=color:#eaae2e>62 </span><span style=color:#db784d>=> </span><span style=color:#eaae2e>6</span><span>,
</span><span>            </span><span style=color:#eaae2e>16 </span><span style=color:#db784d>=> </span><span style=color:#eaae2e>7</span><span>,
</span><span>            </span><span style=color:#eaae2e>54 </span><span style=color:#db784d>=> </span><span style=color:#eaae2e>8</span><span>,
</span><span>            </span><span style=color:#eaae2e>50 </span><span style=color:#db784d>=> </span><span style=color:#eaae2e>9</span><span>,
</span><span>            </span><span style=color:#db784d>_ => return </span><span style=font-style:italic;color:#db784d>Err</span><span>(anyhow!(</span><span style=color:#eaae2e>"Seed parse error"</span><span>)),
</span><span>        };
</span><span>
</span><span>        </span><span style=color:#7a7267>// Keep running tally of the seed as we find each digit
</span><span>        seed </span><span style=color:#db784d>=</span><span> seed </span><span style=color:#db784d>* </span><span style=color:#eaae2e>10 </span><span style=color:#db784d>+</span><span> digit;
</span><span>        x </span><span style=color:#db784d>+= SEED_OFFSETS</span><span>[digit </span><span style=color:#db784d>as </span><span style=color:#95cc5e>usize</span><span>];
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#7a7267>// If there was no seed, return None (for curated puzzles with no seed)
</span><span>    </span><span style=font-style:italic;color:#db784d>Ok</span><span>(seed_present.</span><span style=color:#95cc5e>then_some</span><span>(seed))
</span><span>}
</span></code></pre><h1 id=bringing-it-all-together>Bringing it All Together</h1><p>By this point I had individually figured out how to parse all the parts of the game state. I just had to wrap it all up in a bow with a function that would handle segmenting the image into smaller regions and delegating to the appropriate parsing functions. The result is a populated <code>Puzzle</code> struct.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#7a7267>// Cropping coordinates
</span><span style=color:#95cc5e>const </span><span style=color:#db784d>BOARD_BASE</span><span>: (</span><span style=color:#95cc5e>u32</span><span>, </span><span style=color:#95cc5e>u32</span><span>) </span><span style=color:#db784d>= </span><span>(</span><span style=color:#eaae2e>49</span><span>, </span><span style=color:#eaae2e>175</span><span>);
</span><span style=color:#95cc5e>const </span><span style=color:#db784d>BOARD_SIZE</span><span>: (</span><span style=color:#95cc5e>u32</span><span>, </span><span style=color:#95cc5e>u32</span><span>) </span><span style=color:#db784d>= </span><span>(</span><span style=color:#eaae2e>264</span><span>, </span><span style=color:#eaae2e>265</span><span>);
</span><span style=color:#95cc5e>const </span><span style=color:#db784d>TOP_NUMS_BASE</span><span>: (</span><span style=color:#95cc5e>u32</span><span>, </span><span style=color:#95cc5e>u32</span><span>) </span><span style=color:#db784d>= </span><span>(</span><span style=color:#eaae2e>55</span><span>, </span><span style=color:#eaae2e>138</span><span>);
</span><span style=color:#95cc5e>const </span><span style=color:#db784d>TOP_NUMS_SIZE</span><span>: (</span><span style=color:#95cc5e>u32</span><span>, </span><span style=color:#95cc5e>u32</span><span>) </span><span style=color:#db784d>= </span><span>(</span><span style=color:#eaae2e>263</span><span>, </span><span style=color:#eaae2e>32</span><span>);
</span><span style=color:#95cc5e>const </span><span style=color:#db784d>LEFT_NUMS_BASE</span><span>: (</span><span style=color:#95cc5e>u32</span><span>, </span><span style=color:#95cc5e>u32</span><span>) </span><span style=color:#db784d>= </span><span>(</span><span style=color:#eaae2e>19</span><span>, </span><span style=color:#eaae2e>174</span><span>);
</span><span style=color:#95cc5e>const </span><span style=color:#db784d>LEFT_NUMS_SIZE</span><span>: (</span><span style=color:#95cc5e>u32</span><span>, </span><span style=color:#95cc5e>u32</span><span>) </span><span style=color:#db784d>= </span><span>(</span><span style=color:#eaae2e>32</span><span>, </span><span style=color:#eaae2e>263</span><span>);
</span><span>
</span><span style=color:#95cc5e>impl </span><span>Puzzle {
</span><span>    </span><span style=color:#db784d>pub </span><span style=color:#95cc5e>fn </span><span style=color:#60a365>from_image</span><span>(</span><span style=font-style:italic;color:#f8bb39>img</span><span>: SubImage<</span><span style=color:#db784d>&</span><span>RgbaImage>) -> </span><span style=font-style:italic;color:#db784d>Result</span><span><</span><span style=color:#95cc5e>Self</span><span>> {
</span><span>        </span><span style=color:#7a7267>// Crop regions for the board, seed, and wall counts
</span><span>        </span><span style=color:#95cc5e>let</span><span> tiles </span><span style=color:#db784d>=</span><span> img.</span><span style=color:#95cc5e>view</span><span>(</span><span style=color:#db784d>BOARD_BASE</span><span>.</span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#db784d>BOARD_BASE</span><span>.</span><span style=color:#eaae2e>1</span><span>, </span><span style=color:#db784d>BOARD_SIZE</span><span>.</span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#db784d>BOARD_SIZE</span><span>.</span><span style=color:#eaae2e>1</span><span>);
</span><span>        </span><span style=color:#95cc5e>let</span><span> top_nums </span><span style=color:#db784d>=</span><span> img.</span><span style=color:#95cc5e>view</span><span>(
</span><span>            </span><span style=color:#db784d>TOP_NUMS_BASE</span><span>.</span><span style=color:#eaae2e>0</span><span>,
</span><span>            </span><span style=color:#db784d>TOP_NUMS_BASE</span><span>.</span><span style=color:#eaae2e>1</span><span>,
</span><span>            </span><span style=color:#db784d>TOP_NUMS_SIZE</span><span>.</span><span style=color:#eaae2e>0</span><span>,
</span><span>            </span><span style=color:#db784d>TOP_NUMS_SIZE</span><span>.</span><span style=color:#eaae2e>1</span><span>,
</span><span>        );
</span><span>        </span><span style=color:#95cc5e>let</span><span> left_nums </span><span style=color:#db784d>=</span><span> img.</span><span style=color:#95cc5e>view</span><span>(
</span><span>            </span><span style=color:#db784d>LEFT_NUMS_BASE</span><span>.</span><span style=color:#eaae2e>0</span><span>,
</span><span>            </span><span style=color:#db784d>LEFT_NUMS_BASE</span><span>.</span><span style=color:#eaae2e>1</span><span>,
</span><span>            </span><span style=color:#db784d>LEFT_NUMS_SIZE</span><span>.</span><span style=color:#eaae2e>0</span><span>,
</span><span>            </span><span style=color:#db784d>LEFT_NUMS_SIZE</span><span>.</span><span style=color:#eaae2e>1</span><span>,
</span><span>        );
</span><span>        </span><span style=color:#95cc5e>let</span><span> seed </span><span style=color:#db784d>=</span><span> img.</span><span style=color:#95cc5e>view</span><span>(</span><span style=color:#db784d>SEED_BASE</span><span>.</span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#db784d>SEED_BASE</span><span>.</span><span style=color:#eaae2e>1</span><span>, </span><span style=color:#db784d>SEED_SIZE</span><span>.</span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#db784d>SEED_SIZE</span><span>.</span><span style=color:#eaae2e>1</span><span>);
</span><span>
</span><span>        </span><span style=color:#7a7267>// Parse each region
</span><span>        </span><span style=color:#95cc5e>let</span><span> tiles </span><span style=color:#db784d>= </span><span style=color:#95cc5e>parse_tiles</span><span>(tiles);
</span><span>        </span><span style=color:#95cc5e>let </span><span>(top_nums, left_nums) </span><span style=color:#db784d>= </span><span style=color:#95cc5e>parse_wall_counts</span><span>(top_nums, left_nums)</span><span style=color:#db784d>?</span><span>;
</span><span>        </span><span style=color:#95cc5e>let</span><span> seed </span><span style=color:#db784d>= </span><span style=color:#95cc5e>parse_seed</span><span>(seed)</span><span style=color:#db784d>?</span><span>;
</span><span>
</span><span>        </span><span style=font-style:italic;color:#db784d>Ok</span><span>(</span><span style=color:#95cc5e>Self </span><span>{
</span><span>            tiles,
</span><span>            top_nums,
</span><span>            left_nums,
</span><span>            seed,
</span><span>        })
</span><span>    }
</span><span>}
</span></code></pre><p>I don’t have much more to say about this function, but I whipped up another overlay image to highlight the parsing regions this time. Red for tiles, blue for the two digit regions, and green for the seed.<div class=textCenter><a class=img-link href=overlay.webp><img alt="Pasring overlay" src=overlay.webp></a><div class=caption>The 4 regions being passed to the parsers.</div><br></div><h1 id=serialization-deserialization>Serialization/Deserialization</h1><p>I mentioned in the introduction that I wanted to store parsed puzzles in a file. This would let me run a parsing loop overnight to collect a couple hundred thousand puzzles and use the pre-parsed puzzles in automated testing in the future. To start, I needed to come up with a file format that is relatively compact and simple to read and write.<p>Recall the original definition of the <code>Puzzle</code> struct:<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#95cc5e>struct </span><span>Puzzle {
</span><span>    </span><span style=color:#f8bb39>tiles</span><span>: [[Tile; 8]; 8],
</span><span>    </span><span style=color:#f8bb39>top_nums</span><span>: [</span><span style=color:#95cc5e>u8</span><span>; 8],
</span><span>    </span><span style=color:#f8bb39>left_nums</span><span>: [</span><span style=color:#95cc5e>u8</span><span>; 8],
</span><span>    </span><span style=color:#f8bb39>seed</span><span>: </span><span style=font-style:italic;color:#db784d>Option</span><span><</span><span style=color:#95cc5e>u32</span><span>>,
</span><span>}
</span></code></pre><p>We have <code>tiles</code> which holds 64 variants of the <code>Tile</code> enum. <code>Tile</code> has 5 variants, which would require 3 bits per tile to encode. Remember though that I only care about <code>Monster</code>, <code>Treasure</code>, and <code>Empty</code> states for now. I chose to use two bitmaps to encode the treasure and monster locations, and assume any bit not flagged as either would be empty. I made the bitmap by looping over the tiles and cumulatively bit-shifting the state into two <code>u64</code>s. In the future when I get to generating my own larger puzzles, I will explore run-length encoding of the tile data which should be very efficient.<p>For the top and left wall count numbers, there are a combined 16 values which are between 0-7 inclusive, requiring 3 bits each for a total of 48 bits. I compute the value in a <code>u64</code> and then write out only the lowest 6 bytes.<p>The seed is an optional value which ranges from 0-99999999 (10 million values). I could add an extra bit (requires a full byte) with a flag indicating whether or not the seed is present, but it is be even easier to add 1 to the seed and store a value of 0 in cases when the seed is not present. On deserialization, I do the opposite and subtract 1 for a non-zero seed value. The max value can be represented with only 24 bits, so I use a <code>u32</code> and only write the lowest 3 bytes.<p>This is what the data will look like when written to a 26 byte buffer. It is written in little endian format, chosen arbitrarily.<table><thead><tr><th>Offset<th>Description<tbody><tr><td>0-4<td>Seed<tr><td>4-10<td>Wall Counts<tr><td>10-18<td>Monster Locations<tr><td>18-26<td>Treasure Locations</table><p>The serialization code looks like this:<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#7a7267>// The generic parameter T lets me serialize to a buffer or directly to a file
</span><span style=color:#95cc5e>fn </span><span style=color:#60a365>serialize</span><span>&LTT>(</span><span style=color:#db784d>&</span><span style=font-style:italic;color:#f8bb39>self</span><span>, </span><span style=font-style:italic;color:#f8bb39>cursor</span><span>: </span><span style=color:#db784d>&mut</span><span> T) -> </span><span style=font-style:italic;color:#db784d>Result</span><span><()>
</span><span style=color:#9a9082>where
</span><span>    T: std::io::Write + byteorder::WriteBytesExt,
</span><span>{
</span><span>    </span><span style=color:#7a7267>// Concatenate top and left numbers, fold them 3 bits at a time into a u64
</span><span>    </span><span style=color:#95cc5e>let</span><span> wall_counts: </span><span style=color:#95cc5e>u64 </span><span style=color:#db784d>= </span><span>[</span><span style=color:#207241>self</span><span>.top_nums, </span><span style=color:#207241>self</span><span>.left_nums]
</span><span>        .</span><span style=color:#95cc5e>concat</span><span>()
</span><span>        .</span><span style=color:#95cc5e>iter</span><span>()
</span><span>        .</span><span style=color:#95cc5e>fold</span><span>(</span><span style=color:#eaae2e>0</span><span>, |</span><span style=font-style:italic;color:#f8bb39>acc</span><span>, </span><span style=color:#db784d>&</span><span style=font-style:italic;color:#f8bb39>x</span><span>| (acc </span><span style=color:#db784d><< </span><span style=color:#eaae2e>3</span><span>) </span><span style=color:#db784d>+</span><span> x.</span><span style=color:#95cc5e>min</span><span>(</span><span style=color:#eaae2e>7</span><span>) </span><span style=color:#db784d>as </span><span style=color:#95cc5e>u64</span><span>);
</span><span>
</span><span>    </span><span style=color:#7a7267>// Iterate over each tile, mapping each monster to 1, else 0. Fold into a u64
</span><span>    </span><span style=color:#95cc5e>let</span><span> monster_locations </span><span style=color:#db784d>= </span><span style=color:#207241>self
</span><span>        .tiles
</span><span>        .</span><span style=color:#95cc5e>iter</span><span>()
</span><span>        .</span><span style=color:#95cc5e>flatten</span><span>()
</span><span>        .</span><span style=color:#95cc5e>map</span><span>(|</span><span style=font-style:italic;color:#f8bb39>tile</span><span>| </span><span style=color:#db784d>if </span><span style=color:#95cc5e>let </span><span>Tile::Monster </span><span style=color:#db784d>=</span><span> tile { </span><span style=color:#eaae2e>1 </span><span>} </span><span style=color:#db784d>else </span><span>{ </span><span style=color:#eaae2e>0 </span><span>})
</span><span>        .</span><span style=color:#95cc5e>fold</span><span>(</span><span style=color:#eaae2e>0</span><span>, |</span><span style=font-style:italic;color:#f8bb39>acc</span><span>, </span><span style=font-style:italic;color:#f8bb39>x</span><span>| (acc </span><span style=color:#db784d><< </span><span style=color:#eaae2e>1</span><span>) </span><span style=color:#db784d>+</span><span> x </span><span style=color:#db784d>as </span><span style=color:#95cc5e>u64</span><span>);
</span><span>
</span><span>    </span><span style=color:#7a7267>// Repeat for treasure locations
</span><span>    </span><span style=color:#95cc5e>let</span><span> treasure_locations </span><span style=color:#db784d>= </span><span style=color:#207241>self
</span><span>        .tiles
</span><span>        .</span><span style=color:#95cc5e>iter</span><span>()
</span><span>        .</span><span style=color:#95cc5e>flatten</span><span>()
</span><span>        .</span><span style=color:#95cc5e>map</span><span>(|</span><span style=font-style:italic;color:#f8bb39>tile</span><span>| </span><span style=color:#db784d>if </span><span style=color:#95cc5e>let </span><span>Tile::Treasure </span><span style=color:#db784d>=</span><span> tile { </span><span style=color:#eaae2e>1 </span><span>} </span><span style=color:#db784d>else </span><span>{ </span><span style=color:#eaae2e>0 </span><span>})
</span><span>        .</span><span style=color:#95cc5e>fold</span><span>(</span><span style=color:#eaae2e>0</span><span>, |</span><span style=font-style:italic;color:#f8bb39>acc</span><span>, </span><span style=font-style:italic;color:#f8bb39>x</span><span>| (acc </span><span style=color:#db784d><< </span><span style=color:#eaae2e>1</span><span>) </span><span style=color:#db784d>+</span><span> x </span><span style=color:#db784d>as </span><span style=color:#95cc5e>u64</span><span>);
</span><span>
</span><span>    </span><span style=color:#7a7267>// Seed is 0 for None or (seed + 1) for Some
</span><span>    </span><span style=color:#db784d>if </span><span style=color:#95cc5e>let </span><span style=font-style:italic;color:#db784d>Some</span><span>(seed) </span><span style=color:#db784d>= </span><span style=color:#207241>self</span><span>.seed {
</span><span>        cursor.write_u32::&LTLE>(seed </span><span style=color:#db784d>+ </span><span style=color:#eaae2e>1</span><span>)</span><span style=color:#db784d>?</span><span>;
</span><span>    } </span><span style=color:#db784d>else </span><span>{
</span><span>        cursor.write_u32::&LTLE>(</span><span style=color:#eaae2e>0</span><span>)</span><span style=color:#db784d>?</span><span>;
</span><span>    }
</span><span>    cursor.</span><span style=color:#95cc5e>write_all</span><span>(</span><span style=color:#db784d>&</span><span>wall_counts.</span><span style=color:#95cc5e>to_le_bytes</span><span>()[</span><span style=color:#eaae2e>0</span><span style=color:#db784d>..</span><span style=color:#eaae2e>6</span><span>])</span><span style=color:#db784d>?</span><span>;
</span><span>    cursor.write_u64::&LTLE>(monster_locations)</span><span style=color:#db784d>?</span><span>;
</span><span>    cursor.write_u64::&LTLE>(treasure_locations)</span><span style=color:#db784d>?</span><span>;
</span><span>
</span><span>    </span><span style=font-style:italic;color:#db784d>Ok</span><span>(())
</span><span>}
</span></code></pre><p>Deserialization is basically the same thing but in reverse.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#95cc5e>fn </span><span style=color:#60a365>deserialize</span><span>(</span><span style=font-style:italic;color:#f8bb39>bytes</span><span>: </span><span style=color:#db784d>&</span><span>[</span><span style=color:#95cc5e>u8</span><span>; 26]) -> </span><span style=font-style:italic;color:#db784d>Result</span><span>&LTPuzzle> {
</span><span>    </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> cursor </span><span style=color:#db784d>= </span><span>Cursor::new(bytes);
</span><span>    </span><span style=color:#7a7267>// Read the seed first. Subtract 1 if it was non-zero.
</span><span>    </span><span style=color:#95cc5e>let</span><span> seed </span><span style=color:#db784d>=</span><span> cursor.read_u32::&LTLE>()</span><span style=color:#db784d>?</span><span>;
</span><span>    </span><span style=color:#95cc5e>let</span><span> seed </span><span style=color:#db784d>= if</span><span> seed </span><span style=color:#db784d>== </span><span style=color:#eaae2e>0 </span><span>{ </span><span style=font-style:italic;color:#db784d>None </span><span>} </span><span style=color:#db784d>else </span><span>{ </span><span style=font-style:italic;color:#db784d>Some</span><span>(seed </span><span style=color:#db784d>- </span><span style=color:#eaae2e>1</span><span>) };
</span><span>
</span><span>    </span><span style=color:#7a7267>// Read the packed wall counts into an 8 byte buffer and convert to a u64
</span><span>    </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> wall_counts: [</span><span style=color:#95cc5e>u8</span><span>; </span><span style=color:#eaae2e>8</span><span>] </span><span style=color:#db784d>= </span><span style=font-style:italic;color:#db784d>Default</span><span>::default();
</span><span>    cursor.</span><span style=color:#95cc5e>read_exact</span><span>(</span><span style=color:#db784d>&mut</span><span> wall_counts[</span><span style=color:#eaae2e>0</span><span style=color:#db784d>..</span><span style=color:#eaae2e>6</span><span>])</span><span style=color:#db784d>?</span><span>;
</span><span>    </span><span style=color:#95cc5e>let</span><span> wall_counts </span><span style=color:#db784d>= </span><span style=color:#95cc5e>u64</span><span>::from_le_bytes(wall_counts);
</span><span>
</span><span>    </span><span style=color:#7a7267>// Decode the top and left counts with reverse shift and mask operations
</span><span>    </span><span style=color:#95cc5e>let</span><span> top_nums  </span><span style=color:#db784d>= </span><span>[</span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#eaae2e>1</span><span>, </span><span style=color:#eaae2e>2</span><span>, </span><span style=color:#eaae2e>3</span><span>, </span><span style=color:#eaae2e>4</span><span>, </span><span style=color:#eaae2e>5</span><span>, </span><span style=color:#eaae2e>6</span><span>, </span><span style=color:#eaae2e>7</span><span>].</span><span style=color:#95cc5e>map</span><span>(|</span><span style=font-style:italic;color:#f8bb39>i</span><span>| (wall_counts </span><span style=color:#db784d>>> </span><span>(</span><span style=color:#eaae2e>45 </span><span style=color:#db784d>- </span><span>(i </span><span style=color:#db784d>* </span><span style=color:#eaae2e>3</span><span>))) </span><span style=color:#db784d>as </span><span style=color:#95cc5e>u8 </span><span style=color:#db784d>& </span><span style=color:#eaae2e>0b111</span><span>);
</span><span>    </span><span style=color:#95cc5e>let</span><span> left_nums </span><span style=color:#db784d>= </span><span>[</span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#eaae2e>1</span><span>, </span><span style=color:#eaae2e>2</span><span>, </span><span style=color:#eaae2e>3</span><span>, </span><span style=color:#eaae2e>4</span><span>, </span><span style=color:#eaae2e>5</span><span>, </span><span style=color:#eaae2e>6</span><span>, </span><span style=color:#eaae2e>7</span><span>].</span><span style=color:#95cc5e>map</span><span>(|</span><span style=font-style:italic;color:#f8bb39>i</span><span>| (wall_counts </span><span style=color:#db784d>>> </span><span>(</span><span style=color:#eaae2e>21 </span><span style=color:#db784d>- </span><span>(i </span><span style=color:#db784d>* </span><span style=color:#eaae2e>3</span><span>))) </span><span style=color:#db784d>as </span><span style=color:#95cc5e>u8 </span><span style=color:#db784d>& </span><span style=color:#eaae2e>0b111</span><span>);
</span><span>
</span><span>    </span><span style=color:#7a7267>// Read and unpack the monster/treasure locations
</span><span>    </span><span style=color:#95cc5e>let</span><span> monster_locations </span><span style=color:#db784d>=</span><span> cursor.read_u64::&LTLE>()</span><span style=color:#db784d>?</span><span>;
</span><span>    </span><span style=color:#95cc5e>let</span><span> treasure_locations </span><span style=color:#db784d>=</span><span> cursor.read_u64::&LTLE>()</span><span style=color:#db784d>?</span><span>;
</span><span>    </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> tiles </span><span style=color:#db784d>= </span><span>[[Tile::Empty; </span><span style=color:#eaae2e>8</span><span>]; </span><span style=color:#eaae2e>8</span><span>];
</span><span>    </span><span style=color:#db784d>for</span><span> y </span><span style=color:#db784d>in </span><span style=color:#eaae2e>0</span><span style=color:#db784d>..</span><span style=color:#eaae2e>8 </span><span>{
</span><span>        </span><span style=color:#db784d>for</span><span> x </span><span style=color:#db784d>in </span><span style=color:#eaae2e>0</span><span style=color:#db784d>..</span><span style=color:#eaae2e>8 </span><span>{
</span><span>            </span><span style=color:#95cc5e>let</span><span> i </span><span style=color:#db784d>=</span><span> y </span><span style=color:#db784d>* </span><span style=color:#eaae2e>8 </span><span style=color:#db784d>+</span><span> x;
</span><span>            </span><span style=color:#95cc5e>let</span><span> monster </span><span style=color:#db784d>=</span><span> monster_locations </span><span style=color:#db784d>& </span><span>(</span><span style=color:#eaae2e>1 </span><span style=color:#db784d><< </span><span>(</span><span style=color:#eaae2e>63 </span><span style=color:#db784d>-</span><span> i)) </span><span style=color:#db784d>> </span><span style=color:#eaae2e>0</span><span>;
</span><span>            </span><span style=color:#95cc5e>let</span><span> treasure </span><span style=color:#db784d>=</span><span> treasure_locations </span><span style=color:#db784d>& </span><span>(</span><span style=color:#eaae2e>1 </span><span style=color:#db784d><< </span><span>(</span><span style=color:#eaae2e>63 </span><span style=color:#db784d>-</span><span> i)) </span><span style=color:#db784d>> </span><span style=color:#eaae2e>0</span><span>;
</span><span>            </span><span style=color:#db784d>if</span><span> monster {
</span><span>                tiles[y][x] </span><span style=color:#db784d>= </span><span>Tile::Monster;
</span><span>            } </span><span style=color:#db784d>else if</span><span> treasure {
</span><span>                tiles[y][x] </span><span style=color:#db784d>= </span><span>Tile::Treasure;
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style=font-style:italic;color:#db784d>Ok</span><span>(Puzzle {
</span><span>        tiles,
</span><span>        top_nums,
</span><span>        left_nums,
</span><span>        seed,
</span><span>    })
</span><span>}
</span></code></pre><p>I’ll be honest, this didn’t work immediately on my first attempt. The problem had to do with the bitshift offsets which I fixed quickly and then wrote a loop to cycle through puzzles and write them to a file.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#95cc5e>const </span><span style=color:#db784d>DB_PATH</span><span>: </span><span style=color:#db784d>&</span><span style=color:#95cc5e>str </span><span style=color:#db784d>= </span><span style=color:#eaae2e>"data"</span><span>;
</span><span style=color:#95cc5e>const </span><span style=color:#db784d>DB_FILE</span><span>: </span><span style=color:#db784d>&</span><span style=color:#95cc5e>str </span><span style=color:#db784d>= </span><span style=color:#eaae2e>"puzzles.db"</span><span>;
</span><span style=color:#95cc5e>const </span><span style=color:#db784d>PUZZLES_PER_BATCH</span><span>: </span><span style=color:#95cc5e>usize </span><span style=color:#db784d>= </span><span style=color:#eaae2e>100</span><span>;
</span><span style=color:#95cc5e>fn </span><span style=color:#60a365>collect_puzzles</span><span>() -> </span><span style=font-style:italic;color:#db784d>Result</span><span><()> {
</span><span>    </span><span style=color:#7a7267>// Create db file if it doesn't exist
</span><span>    </span><span style=color:#95cc5e>let</span><span> db_path </span><span style=color:#db784d>= </span><span>Path::new(</span><span style=color:#db784d>DB_PATH</span><span>).</span><span style=color:#95cc5e>join</span><span>(</span><span style=color:#db784d>DB_FILE</span><span>);
</span><span>    </span><span style=color:#db784d>if !</span><span>db_path.</span><span style=color:#95cc5e>exists</span><span>() {
</span><span>        fs::create_dir_all(</span><span style=color:#db784d>DB_PATH</span><span>)</span><span style=color:#db784d>?</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#7a7267>// Instantiate dungeon crawler and open db file in append mode
</span><span>    </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> dc </span><span style=color:#db784d>= </span><span>dungeon_crawler::DungeonCrawler::new()</span><span style=color:#db784d>?</span><span>;
</span><span>    </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> file </span><span style=color:#db784d>= </span><span>OpenOptions::new()
</span><span>        .</span><span style=color:#95cc5e>write</span><span>(</span><span style=color:#db784d>true</span><span>)
</span><span>        .</span><span style=color:#95cc5e>append</span><span>(</span><span style=color:#db784d>true</span><span>)
</span><span>        .</span><span style=color:#95cc5e>create</span><span>(</span><span style=color:#db784d>true</span><span>)
</span><span>        .</span><span style=color:#95cc5e>open</span><span>(db_path)
</span><span>        .</span><span style=color:#95cc5e>expect</span><span>(</span><span style=color:#eaae2e>"Database file should have been created"</span><span>);
</span><span>
</span><span>    </span><span style=color:#7a7267>// Create buffer to serialize puzzles into
</span><span>    </span><span style=color:#95cc5e>let</span><span> buffer </span><span style=color:#db784d>= </span><span style=font-style:italic;color:#db784d>Vec</span><span>::new();
</span><span>    </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> cursor </span><span style=color:#db784d>= </span><span>Cursor::new(buffer);
</span><span>
</span><span>    </span><span style=color:#95cc5e>let</span><span> t0 </span><span style=color:#db784d>= </span><span>Instant::now();
</span><span>
</span><span>    </span><span style=color:#db784d>for _ in </span><span style=color:#eaae2e>0</span><span style=color:#db784d>..PUZZLES_PER_BATCH </span><span>{
</span><span>        dc.</span><span style=color:#95cc5e>random_board</span><span>();
</span><span>        </span><span style=color:#95cc5e>let</span><span> puzzle </span><span style=color:#db784d>=</span><span> dc.</span><span style=color:#95cc5e>parse</span><span>()</span><span style=color:#db784d>?</span><span>;
</span><span>        puzzle.</span><span style=color:#95cc5e>serialize</span><span>(</span><span style=color:#db784d>&mut</span><span> cursor)</span><span style=color:#db784d>?</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#7a7267>// Append buffer to file
</span><span>    file.</span><span style=color:#95cc5e>write_all</span><span>(</span><span style=color:#db784d>&</span><span>cursor.</span><span style=color:#95cc5e>into_inner</span><span>())</span><span style=color:#db784d>?</span><span>;
</span><span>
</span><span>    </span><span style=color:#95cc5e>let</span><span> elapsed </span><span style=color:#db784d>=</span><span> t0.</span><span style=color:#95cc5e>elapsed</span><span>();
</span><span>    println!(
</span><span>        </span><span style=color:#eaae2e>"</span><span style=color:#db784d>{PUZZLES_PER_BATCH}</span><span style=color:#eaae2e> parsed in {:.02}s. ({:.02}/s)"</span><span>,
</span><span>        elapsed.</span><span style=color:#95cc5e>as_secs_f32</span><span>(),
</span><span>        </span><span style=color:#db784d>PUZZLES_PER_BATCH as </span><span style=color:#95cc5e>f32 </span><span style=color:#db784d>/</span><span> elapsed.</span><span style=color:#95cc5e>as_secs_f32</span><span>()
</span><span>    );
</span><span>
</span><span>    </span><span style=font-style:italic;color:#db784d>Ok</span><span>(())
</span><span>}
</span></code></pre><p>I collected 100 puzzles at a time and appended them to the database file. When I ran it, it cycled through all 100 puzzles and parsed them in about 3.6 seconds, or 28 puzzles/second. I suspect the theoretical maximum would be 165/sec (my monitors refresh rate, with 1 puzzle per frame). I may try to push my speed here in the future but for now I am happy with ~30/sec.<p>I wrote some companion functions to read all the puzzles and parse them, and output the total count and the number that are unique.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#7a7267>/// Read and parse all the puzzles in the database.
</span><span style=color:#95cc5e>fn </span><span style=color:#60a365>read_puzzles</span><span>() -> </span><span style=font-style:italic;color:#db784d>Result</span><span><</span><span style=font-style:italic;color:#db784d>Vec</span><span>&LTPuzzle>> {
</span><span>    </span><span style=color:#95cc5e>let</span><span> db_path </span><span style=color:#db784d>= </span><span>Path::new(</span><span style=color:#db784d>DB_PATH</span><span>).</span><span style=color:#95cc5e>join</span><span>(</span><span style=color:#db784d>DB_FILE</span><span>);
</span><span>    </span><span style=color:#95cc5e>let</span><span> buffer </span><span style=color:#db784d>= </span><span>fs::read(db_path)</span><span style=color:#db784d>?</span><span>;
</span><span>
</span><span>    </span><span style=color:#95cc5e>let</span><span> puzzles </span><span style=color:#db784d>=</span><span> buffer
</span><span>        .array_chunks::&LT26>()
</span><span>        .</span><span style=color:#95cc5e>map</span><span>(|</span><span style=font-style:italic;color:#f8bb39>chunk</span><span>| puzzle::Puzzle::deserialize(chunk))
</span><span>        .collect::<</span><span style=font-style:italic;color:#db784d>Result</span><span><</span><span style=font-style:italic;color:#db784d>Vec</span><span>&LTpuzzle::Puzzle>>>()</span><span style=color:#db784d>?</span><span>;
</span><span>
</span><span>    </span><span style=font-style:italic;color:#db784d>Ok</span><span>(puzzles)
</span><span>}
</span><span>
</span><span style=color:#7a7267>/// Count the number of puzzles and see how many are unique.
</span><span style=color:#95cc5e>fn </span><span style=color:#60a365>print_db_info</span><span>() -> </span><span style=font-style:italic;color:#db784d>Result</span><span><()> {
</span><span>    </span><span style=color:#95cc5e>let</span><span> puzzles </span><span style=color:#db784d>= </span><span style=color:#95cc5e>read_puzzles</span><span>()</span><span style=color:#db784d>?</span><span>;
</span><span>
</span><span>    </span><span style=color:#95cc5e>let</span><span> seeds: HashSet<</span><span style=color:#95cc5e>u32</span><span>> </span><span style=color:#db784d>= </span><span>HashSet::from_iter(
</span><span>        puzzles
</span><span>            .</span><span style=color:#95cc5e>iter</span><span>()
</span><span>            .</span><span style=color:#95cc5e>map</span><span>(|</span><span style=font-style:italic;color:#f8bb39>puzzle</span><span>| puzzle.seed.</span><span style=color:#95cc5e>unwrap_or</span><span>(</span><span style=color:#eaae2e>10000000</span><span style=color:#95cc5e>u32</span><span>)),
</span><span>    );
</span><span>
</span><span>    println!(</span><span style=color:#eaae2e>"Puzzle database"</span><span>);
</span><span>    println!(</span><span style=color:#eaae2e>"  count: </span><span style=color:#db784d>{}</span><span style=color:#eaae2e>"</span><span>, puzzles.</span><span style=color:#95cc5e>len</span><span>());
</span><span>    println!(</span><span style=color:#eaae2e>"  unique: </span><span style=color:#db784d>{}</span><span style=color:#eaae2e>"</span><span>, seeds.</span><span style=color:#95cc5e>len</span><span>());
</span><span>
</span><span>    </span><span style=font-style:italic;color:#db784d>Ok</span><span>(())
</span><span>}
</span></code></pre><pre style=background:#191919;color:#e8d4c0><code><span> Puzzle database
</span><span>   count: 5000
</span><span>   unique: 5000
</span></code></pre><p>After 5000 puzzles there were no duplicates which I guess makes sense given a sample size of 10 million. I’ll use this database in the next post when I begin solving them. This concludes the bulk of the content I wanted to cover in this post, but if you haven’t had enough yet, read on for some bonus content on testing.<h1 id=bonus-testing>(Bonus) Testing</h1><p>I had now written parsing, serialization, and deserialization routines for puzzles and I wanted to add a bit of automated testing to make sure that A) these functions are doing what I intended, and B) they don’t break in the future if I make modifications to the serialization format or parsing routines. I started with a parsing test that took an image as an input and compared the parsed <code>Puzzle</code> with a manually verified struct literal. I added one test case per each of the 18 different enemy types, some with and some without seeds. I learned about and made use of the <code>test-case</code> crate which let me write a single test case and instantiate it multiple times for different input data.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span style=color:#7a7267>// This function lets me lookup the verified puzzles by monster name. I've ommitted 17 other cases for brevity.
</span><span style=color:#95cc5e>fn </span><span style=color:#60a365>get_reference_puzzle</span><span>(</span><span style=font-style:italic;color:#f8bb39>monster</span><span>: </span><span style=color:#db784d>&</span><span style=color:#95cc5e>str</span><span>) -> Puzzle {
</span><span>    </span><span style=color:#9a9082>use </span><span>Tile::</span><span style=color:#db784d>*</span><span>;
</span><span>    </span><span style=color:#db784d>match</span><span> monster {
</span><span>        </span><span style=color:#eaae2e>"slime" </span><span style=color:#db784d>=></span><span> Puzzle {
</span><span>            tiles: [
</span><span>                [Empty, Empty, Monster, Empty, Empty, Empty, Monster, Empty],
</span><span>                [Empty, Empty, Empty, Empty, Monster, Empty, Empty, Monster],
</span><span>                [Empty, Empty, Empty, Empty, Empty, Empty, Empty, Empty],
</span><span>                [Empty, Empty, Empty, Empty, Empty, Empty, Empty, Empty],
</span><span>                [Empty, Empty, Empty, Empty, Empty, Empty, Empty, Empty],
</span><span>                [Empty, Empty, Empty, Monster, Empty, Monster, Empty, Empty],
</span><span>                [Monster, Empty, Empty, Empty, Empty, Empty, Empty, Monster],
</span><span>                [Empty, Empty, Empty, Empty, Empty, Monster, Empty, Empty],
</span><span>            ],
</span><span>            top_nums: [</span><span style=color:#eaae2e>4</span><span>, </span><span style=color:#eaae2e>2</span><span>, </span><span style=color:#eaae2e>4</span><span>, </span><span style=color:#eaae2e>4</span><span>, </span><span style=color:#eaae2e>3</span><span>, </span><span style=color:#eaae2e>4</span><span>, </span><span style=color:#eaae2e>3</span><span>, </span><span style=color:#eaae2e>4</span><span>],
</span><span>            left_nums: [</span><span style=color:#eaae2e>4</span><span>, </span><span style=color:#eaae2e>4</span><span>, </span><span style=color:#eaae2e>1</span><span>, </span><span style=color:#eaae2e>5</span><span>, </span><span style=color:#eaae2e>2</span><span>, </span><span style=color:#eaae2e>4</span><span>, </span><span style=color:#eaae2e>4</span><span>, </span><span style=color:#eaae2e>4</span><span>],
</span><span>            seed: </span><span style=font-style:italic;color:#db784d>Some</span><span>(</span><span style=color:#eaae2e>6606032</span><span>),
</span><span>        },
</span><span>        </span><span style=color:#7a7267>// < 17 other cases >
</span><span>        </span><span style=color:#db784d>_ => </span><span>Puzzle::default(),
</span><span>    }
</span><span>}
</span><span>
</span><span>#[</span><span style=color:#207241>test_case</span><span>(</span><span style=color:#eaae2e>"bear"</span><span>)]
</span><span>#[</span><span style=color:#207241>test_case</span><span>(</span><span style=color:#eaae2e>"chest"</span><span>)]
</span><span style=color:#7a7267>// < 14 more monsters >
</span><span>#[</span><span style=color:#207241>test_case</span><span>(</span><span style=color:#eaae2e>"slime"</span><span>)]
</span><span>#[</span><span style=color:#207241>test_case</span><span>(</span><span style=color:#eaae2e>"squid"</span><span>)]
</span><span style=color:#7a7267>/// Tests that images can be successfully parsed by comparing to reference results.
</span><span style=color:#95cc5e>fn </span><span style=color:#60a365>parse</span><span>(</span><span style=font-style:italic;color:#f8bb39>monster</span><span>: </span><span style=color:#db784d>&</span><span style=color:#95cc5e>str</span><span>) {
</span><span>    </span><span style=color:#7a7267>// Open the image
</span><span>    </span><span style=color:#95cc5e>let</span><span> path </span><span style=color:#db784d>= </span><span>std::path::Path::new(</span><span style=color:#eaae2e>"monster_refs"</span><span>).</span><span style=color:#95cc5e>join</span><span>(format!(</span><span style=color:#eaae2e>"</span><span style=color:#db784d>{monster}</span><span style=color:#eaae2e>.png"</span><span>));
</span><span>    </span><span style=color:#95cc5e>let</span><span> img </span><span style=color:#db784d>= </span><span style=color:#95cc5e>open</span><span>(path).</span><span style=color:#95cc5e>expect</span><span>(</span><span style=color:#eaae2e>"{monster}.png not found"</span><span>).</span><span style=color:#95cc5e>to_rgba8</span><span>();
</span><span>
</span><span>    </span><span style=color:#7a7267>// Parse it
</span><span>    </span><span style=color:#95cc5e>let</span><span> p </span><span style=color:#db784d>= </span><span>Puzzle::from_image(img.</span><span style=color:#95cc5e>view</span><span>(</span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#eaae2e>0</span><span>, img.</span><span style=color:#95cc5e>width</span><span>(), img.</span><span style=color:#95cc5e>height</span><span>())).</span><span style=color:#95cc5e>unwrap</span><span>();
</span><span>
</span><span>    </span><span style=color:#7a7267>// Print the incorrect result on failure for debugging
</span><span>    assert!(p </span><span style=color:#db784d>== </span><span style=color:#95cc5e>get_reference_puzzle</span><span>(monster), </span><span style=color:#eaae2e>"{monster} => {p:?},"</span><span>)
</span><span>}
</span></code></pre><p>This test case actually helped me to find a bug in my seed parsing, due to not properly handling the case for curated puzzles where there is no seed.<p>The second test I added was a round-trip serialization/deserialization operation. It opens the image and parses it, then serializes it to a buffer and attempts to deserialize the buffer back into a struct. Comparing the pre- and post-serialization structs lets me know if I am clobbering any data in the process.<pre class=language-rust data-lang=rust style=background:#191919;color:#e8d4c0><code class=language-rust data-lang=rust><span>#[</span><span style=color:#207241>test_case</span><span>(</span><span style=color:#eaae2e>"bear"</span><span>)]
</span><span>#[</span><span style=color:#207241>test_case</span><span>(</span><span style=color:#eaae2e>"chest"</span><span>)]
</span><span style=color:#7a7267>// < 14 more monsters >
</span><span>#[</span><span style=color:#207241>test_case</span><span>(</span><span style=color:#eaae2e>"slime"</span><span>)]
</span><span>#[</span><span style=color:#207241>test_case</span><span>(</span><span style=color:#eaae2e>"squid"</span><span>)]
</span><span style=color:#7a7267>/// Test that a screenshot can be parsed, and the serialization/deserialization
</span><span style=color:#7a7267>/// round trip doesn't clobber any data
</span><span style=color:#95cc5e>fn </span><span style=color:#60a365>serialization</span><span>(</span><span style=font-style:italic;color:#f8bb39>monster</span><span>: </span><span style=color:#db784d>&</span><span style=color:#95cc5e>str</span><span>) {
</span><span>    </span><span style=color:#7a7267>// Open the image and do initial parsing.
</span><span>    </span><span style=color:#95cc5e>let</span><span> path </span><span style=color:#db784d>= </span><span>Path::new(</span><span style=color:#eaae2e>"monster_refs"</span><span>).</span><span style=color:#95cc5e>join</span><span>(format!(</span><span style=color:#eaae2e>"</span><span style=color:#db784d>{monster}</span><span style=color:#eaae2e>.png"</span><span>));
</span><span>    </span><span style=color:#95cc5e>let</span><span> img </span><span style=color:#db784d>= </span><span style=color:#95cc5e>open</span><span>(path).</span><span style=color:#95cc5e>expect</span><span>(</span><span style=color:#eaae2e>"Open {path}"</span><span>).</span><span style=color:#95cc5e>to_rgba8</span><span>();
</span><span>    </span><span style=color:#95cc5e>let</span><span> original </span><span style=color:#db784d>= </span><span>Puzzle::from_image(img.</span><span style=color:#95cc5e>view</span><span>(</span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#eaae2e>0</span><span>, img.</span><span style=color:#95cc5e>width</span><span>(), img.</span><span style=color:#95cc5e>height</span><span>())).</span><span style=color:#95cc5e>unwrap</span><span>()
</span><span>
</span><span>    </span><span style=color:#7a7267>// Create a buffer and serialize the puzzle into it.
</span><span>    </span><span style=color:#95cc5e>let</span><span> write_buffer </span><span style=color:#db784d>= </span><span style=font-style:italic;color:#db784d>Vec</span><span>::with_capacity(</span><span style=color:#eaae2e>1000</span><span>);
</span><span>    </span><span style=color:#95cc5e>let </span><span style=color:#db784d>mut</span><span> cursor </span><span style=color:#db784d>= </span><span>Cursor::new(write_buffer);
</span><span>    original.</span><span style=color:#95cc5e>serialize</span><span>(</span><span style=color:#db784d>&mut</span><span> cursor).</span><span style=color:#95cc5e>unwrap</span><span>();
</span><span>
</span><span>    </span><span style=color:#7a7267>// Fetch the buffer back from the Cursor wrapper, and pass it to the deserializer
</span><span>    </span><span style=color:#95cc5e>let</span><span> read_buffer </span><span style=color:#db784d>=</span><span> cursor.</span><span style=color:#95cc5e>into_inner</span><span>();
</span><span>    </span><span style=color:#95cc5e>let</span><span> deserialized </span><span style=color:#db784d>= </span><span>Puzzle::deserialize(read_buffer.first_chunk::&LT26>().</span><span style=color:#95cc5e>unwrap</span><span>()).</span><span style=color:#95cc5e>unwrap</span><span>();
</span><span>
</span><span>    assert!(deserialized </span><span style=color:#db784d>==</span><span> original, </span><span style=color:#eaae2e>"Original:</span><span style=color:#db784d>\n</span><span style=color:#eaae2e>{original}</span><span style=color:#db784d>\n</span><span style=color:#eaae2e>Deserialized:</span><span style=color:#db784d>\n</span><span style=color:#eaae2e>{deserialized}"</span><span>);
</span><span>}
</span></code></pre><p>Likewise, this test also caught a bug in how I handled the optional <code>seed</code> parameter with deserialization, and thankfully it was a quick fix. This was my first real foray into rust’s testing framework and I am pretty happy with being able to simply run <code>cargo test</code> and see my results summarized right away.<h1 id=conclusion>Conclusion</h1><p>This post ended up being significantly longer than I was expecting, especially with the detour <a href=../dnd-pt2-5/>post</a>. We covered converting pixels to structs, serialization, and automated testing. If you made it this far, thanks for tuning in and get ready for the next post where I’ll be attempting to solve some puzzles for the first time using backtracking!<p class=tagsData></main><footer><hr><div class=footContainer><div class=footLeft><p>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme.<br></div></div></footer></div>